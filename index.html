<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Tower Defense ‚Äî –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–π –≤–∞–º –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç –∑–∞—â–∏—â–∞—Ç—å —Å–≤–æ—é –±–∞–∑—É –æ—Ç –≤–æ–ª–Ω –≤—Ä–∞–≥–æ–≤, —Å—Ç—Ä–æ—è —Ä–∞–∑–ª–∏—á–Ω—ã–µ –±–∞—à–Ω–∏ –∏ –ø—Ä–∏–º–µ–Ω—è—è —Ç–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–µ–º—ã.">
  <meta name="keywords" content="Tower Defense, —Å—Ç—Ä–∞—Ç–µ–≥–∏—è, –∏–≥—Ä–∞, –∑–∞—â–∏—Ç–∞, –±–∞–∑—É, –±–∞—à–Ω–∏, –≤—Ä–∞–≥–∏">
  <meta name="author" content="–ú–∞–≥–æ–º–µ–¥–æ–≤ –ê–Ω—Ç–æ–Ω / @xcve33">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  
  <title> 0.2.0 Tower Defense ‚Äî –í—Å—ë –≤ –æ–¥–Ω–æ–º</title>

 <style>
  /* –ö–æ—Ä–Ω–µ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ */
  :root {
    --bg-color: #28323a;
    --text-color: #ebebeb;
    --canvas-bg: #1d2227;
    --border-color: #444;
    --panel-bg: #222a30;
    --panel-border: #333;
    --primary-btn-bg: #48607c;
    --selected-btn-bg: #b36218;
    --money-color: #f9d648;
    --health-color: #d9675f;
    --wave-color: #76e0a6;
    --success-color: #58a181;
    --failure-color: #b84c4c;
    --shadow-color: rgba(53, 93, 38, 0.5);
  }

  /* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ */
  html, body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
    background: var(--bg-color);
    color: var(--text-color);
    overflow: hidden; /* –£–±–∏—Ä–∞–µ–º —Å–∫—Ä–æ–ª–ª–∏–Ω–≥ */
  }

  /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∏–≥—Ä—ã –∏ UI */
    .game-container {
      display: flex;
      flex-direction: column; /* –†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ */
      align-items: center;    /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ */
      margin: 20px;          /* –û–±—â–∏–π –æ—Ç—Å—Ç—É–ø –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
      max-width: 800px;      /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É */
      width: 100%;           /* –ó–∞–ø–æ–ª–Ω—è–µ–º –≤—Å—é —à–∏—Ä–∏–Ω—É –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ */
    }

  /* –°—Ç–∏–ª–∏ –∫–∞–Ω–≤–∞—Å–∞ */
  canvas {
    display: block;
    background: var(--canvas-bg);
    margin: 20px auto;
    border: 3px solid var(--border-color);
    max-width: 100%; /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É –∫–∞–Ω–≤–∞—Å–∞ */
    height: auto; /* –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ */
  }

  /* UI-–ø–∞–Ω–µ–ª—å */
  .ui-panel {
    max-width: 800px;
    margin: 20px auto 0; /* –û—Ç—Å—Ç—É–ø —Å–≤–µ—Ä—Ö—É, —á—Ç–æ–±—ã –ø–∞–Ω–µ–ª—å –±—ã–ª–∞ –Ω–∏–∂–µ –∫–∞–Ω–≤–∞—Å–∞ */
    padding: 8px;
    text-align: left;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 8px;
  }

  /* –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫ —Å–ª–µ–¥—É—é—â–µ–π –≤–æ–ª–Ω—ã */
  #btnNextWave {
    display: block; /* –°–¥–µ–ª–∞–µ–º –∫–Ω–æ–ø–∫—É –±–ª–æ—á–Ω–æ–π, —á—Ç–æ–±—ã –æ–Ω–∞ –∑–∞–Ω–∏–º–∞–ª–∞ –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é —à–∏—Ä–∏–Ω—É */
    margin: 10px auto; 
    padding: 10px 20px;
    font-size: 18px;
    background: var(--primary-btn-bg);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.15s;
  }

  #btnNextWave:hover {
    background: var(--selected-btn-bg);
  }

  /* –ö–Ω–æ–ø–∫–∏ –≤ –ø–∞–Ω–µ–ª–∏ */
  .ui-panel button {
    margin: 3px; 
    font-size: 16px; 
    background: var(--primary-btn-bg); 
    color: #fff; 
    border: none; 
    border-radius: 5px; 
    cursor: pointer; 
    padding: 6px 20px; 
    transition: background 0.15s; 
    display: inline-block; 
  }

  .ui-panel button.selected {
    background: var(--selected-btn-bg);
    animation: green-blink 0.34s infinite;
    outline: 3px dashed #15ff00 !important;
    border: 2px solid #fff !important;
    box-shadow: 0 0 15px 4px var(--shadow-color);
  }

  /* –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∞–ø–≥—Ä–µ–π–¥–∞ –∏ –ø—Ä–æ–¥–∞–∂–∏ */
  .upgrade-sell-buttons {
    display: flex; /* –ò—Å–ø–æ–ª—å–∑—É–µ–º flex –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–Ω–æ–ø–æ–∫ */
    justify-content: flex-start; /* –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é */
    gap: 10px; /* –ü—Ä–æ–±–µ–ª –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ */
    margin: 10px 0; /* –û—Ç—Å—Ç—É–ø —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É */
  }

  .upgrade-sell-buttons button {
    background: var(--primary-btn-bg); 
    color: #fff; 
    border: none; 
    border-radius: 5px; 
    cursor: pointer; 
    padding: 6px 10px; 
    transition: background 0.15s; 
    font-size: 16px; /* –†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –∫–Ω–æ–ø–∫–∏ */
  }

  .upgrade-sell-buttons button:hover {
    background: var(--selected-btn-bg);
  }

  /* –°—Ç–∞—Ç—É—Å–Ω—ã–µ —Å—Ç–∏–ª–∏ */
  .money { color: var(--money-color); font-weight: bold; }
  .health { color: var(--health-color); font-weight: bold; }
  .wave { color: var(--wave-color); }

  /* –¢–∞–π–º–µ—Ä –≤–æ–ª–Ω—ã */
  .wave-counter {
    position: absolute;
    right: 20px;
    top: 10px;
    font-weight: bold;
    font-size: 1.25em;
    background: rgba(53, 93, 38, 0.7);
    border-radius: 8px;
    padding: 4px 12px;
    color: #96f586;
    z-index: 2;
    box-shadow: 0 0 12px #202;
  }

  /* –≠–ª–µ–º–µ–Ω—Ç—ã –ø–æ–±–µ–¥—ã –∏ –ø–æ—Ä–∞–∂–µ–Ω–∏—è */
  .gameover, .victory {
    background: rgba(15, 22, 27, 0.8);
    padding: 40px 80px;
    position: absolute;
    top: 50%; /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ */
    left: 50%;
    transform: translate(-50%, -50%); /* –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ */
    color: #fff;
    border-radius: 18px;
    border: 4px solid #dda000;
    font-size: 2em;
    letter-spacing: 0.08em;
    z-index: 3;
    text-align: center;
  }

  /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ */
  .dev-panel {
    font-size: 13px;
    max-width: 760px;
    margin: 5px auto;
    padding: 4px 8px;
    color: #9cf;
    background: #173045;
  }

  /* –ê–Ω–∏–º–∞—Ü–∏–∏ */
  @keyframes green-blink {
    0%, 100% { 
      outline: 3px dashed #0f0; 
      box-shadow: 0 0 15px 4px var(--shadow-color);
    }
    50% { 
      outline: 3px dashed #00ffae; 
      box-shadow: 0 0 15px 6px #00ffae94; 
    }
  }

  @keyframes pulse-green {  
    0%, 100% { outline: 3px solid #36ef97cc; }  
    50% { outline: 3px solid #3bd1d4aa; }  
  }
  
  @keyframes pulse-red {  
    0%, 100% { outline: 3px solid #d1573dcc; }  
    50% { outline: 3px solid #ec2323bb; }  
  }

  /* –°—Ç–∏–ª–∏ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ */
  .building-cell-allowed {  
    box-shadow: 0 0 14px var(--success-color) !important;  
    animation: pulse-green 0.82s infinite;  
  }  
  .building-cell-denied {  
    box-shadow: 0 0 14px var(--failure-color) !important;  
    animation: pulse-red 0.82s infinite;  
  }

  /* –¢–∞–±–ª–∏—Ü—ã –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞—à–Ω—è—Ö */
  .tower-info-table {
    width: 98%;
    font-size: 15px;
    margin: 10px auto;
    border-collapse: collapse;
  }
  .tower-info-table tbody tr td {
    padding: 4px 8px;
    vertical-align: middle;
  }
  .tower-info-table .col-left {
    text-align: right;
    min-width: 48px;
  }
  .tower-info-table .col-center {
    text-align: center;
    font-weight: bold;
    min-width: 54px;
  }
  .tower-info-table .col-right {
    text-align: left;
    min-width: 48px;
  }
  .tower-info-table .label-cell {
    opacity: 0.6;
    text-align: left;
  }
  .tower-info-table .dimmed {
    opacity: 0.32;
  }
  .tower-info-laser {
    background-color: #222;
    color: #8f8;
    font-weight: bold;
  }
  .tower-info-dot {
    background-color: #222;
    color: #f88;
    font-weight: bold;
  }
  .tower-info-extra-row td {
    text-align: center;
    padding: 6px 0;
    font-weight: bold;
  }

  
</style>
</head>  

<body>
  <div class="game-container">
    <canvas id="game"></canvas>

    <div class="ui-panel" id="ui-panel"></div>

    <button id="btnNextWave" class="td-btn">–ó–ê–ü–£–°–¢–ò–¢–¨ –°–õ–ï–î–£–Æ–©–£–Æ –í–û–õ–ù–£</button>
    <span id="wave-timer" class="wave-counter" style="display:none"></span>

    <div class="dev-panel" id="dev-panel" style="display:none"></div>
  </div>


    <div id="tower-info" style="
    display:none;
    position:absolute;
    top:80px; left:50px;
    min-width:180px;
    background:#181a22;
    color:#fff;
    padding:12px 14px;
    border-radius:8px;
    box-shadow:0 0 12px #28285a;
    z-index:10;
    font-family:monospace;
    font-size:15px;"
></div>


  
</body>

</html>

<script>  


// ===== 1. –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã =====  
const GRID_SIZE = 15;  
const CELL_SIZE = 40;  
const CANVAS_WIDTH = GRID_SIZE * CELL_SIZE;  
const CANVAS_HEIGHT = GRID_SIZE * CELL_SIZE;  

// –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –≤–æ–ª–Ω—ã (–ø–æ–¥ —Ç–≤–æ—é waveData)
function spawnWave(num) {
    const waveCfg = waveData[num];
    if (!waveCfg || !Array.isArray(waveCfg.enemies)) {
        console.log(`–í–æ–ª–Ω–∞ #${num + 1}: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö!`);
        return;
    }
    const desc = waveCfg.enemies.map(
        e => `${e.n} –≤—Ä–∞–≥–æ–≤ —Ç–∏–ø–∞ #${e.e} (d=${e.d})`
    ).join(', ');
    console.log(`–ó–∞–ø—É—â–µ–Ω–∞ –≤–æ–ª–Ω–∞ #${num + 1}: ${desc}`);
    // –ó–¥–µ—Å—å —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ –∑–∞–ø—É—Å–∫–∞ –æ—á–µ—Ä–µ–¥–∏ –≤—Ä–∞–≥–æ–≤!
}

// –ù–∞–¥—ë–∂–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –∑–∞–ø—É—Å–∫–∞ –≤–æ–ª–Ω—ã
document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('btnNextWave');
    const timer = document.getElementById('wave-timer');

    btn.onclick = () => {
        if (gameOver) return;
        if (wave >= waveData.length) {
            btn.disabled = true;
            btn.textContent = '–í–û–õ–ù–´ –ó–ê–ö–û–ù–ß–ò–õ–ò–°–¨';
            return;
        }
        spawnWave(wave);
        // –°—á–∏—Ç–∞–µ–º —Å—É–º–º–∞—Ä–Ω–æ –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤ –≤ –≤–æ–ª–Ω–µ:
        spawnLeft = waveData[wave].enemies.reduce((sum, e) => sum + e.n, 0);
        wave++;
        timer.style.display = 'none';

        if (wave >= waveData.length) {
            btn.disabled = true;
            btn.textContent = '–í–û–õ–ù–´ –ó–ê–ö–û–ù–ß–ò–õ–ò–°–¨';
            btn.classList.add('disabled');
        }
    };
});

const enemyData = [  
  { name: "–Ø–±–ª–æ–∫–æ",  hp: 80,    speed: 250, color: '#ff3e3e', reward: 7, damage: 1 },  
  { name: "–ë–∞–Ω–∞–Ω",   hp: 120,   speed: 120, color: '#fcbf2f', reward: 6, damage: 1 },  
  { name: "–ê–≤–æ–∫–∞–¥–æ", hp: 850,   speed: 100, color: '#8fc74e', reward: 15, damage: 2 },  
  { name: "–ê—Ä–±—É–∑",   hp: 4000,  speed: 200, color: '#4edc9e', reward: 120, damage: 4 },
  { name: "–î—ã–Ω—è",    hp: 2000,  speed: 300, color: '#ffca98', reward: 180, damage: 4 },  
  { name: "–ì—Ä—É—à–∞",   hp: 8000,  speed: 200, color: '#a7d09b', reward: 65, damage: 4 },
  { name: "–ö–∞–ø—É—Å—Ç–∞", hp: 5000,  speed: 50,  color: '#a3d0a6', reward: 100, damage: 3 },
  { name: "–°–≤–µ–∫–ª–∞",  hp: 6000,  speed: 60,  color: '#c84b3f', reward: 110, damage: 5 },
  { name: "–ë–∞–∫–ª–∞–∂–∞–Ω", hp: 70000, speed: 70,  color: '#5c3e7f', reward: 130, damage: 6 },
  { name: "–ü–æ–º–∏–¥–æ—Ä", hp: 75000,  speed: 80,  color: '#ff4d4d', reward: 140, damage: 6 },
  { name: "–¢—ã–∫–≤–∞",   hp: 100000, speed: 30,  color: '#ff9838', reward: 200, damage: 8 }
];

// –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∑–¥–æ—Ä–æ–≤—å—è (hp)
// enemyData.sort((a, b) => a.hp - b.hp);


const towerData = [
  // üå∏ –î–ï–®–Å–í–´–ï –ë–ê–®–ù–ò (–¥–ª—è —Å—Ç–∞—Ä—Ç–∞)
  {
    name: "üê≠ –ú—ã—à–∫–∞",
    cost: 15,
    range: 3.0,
    damage: 8,
    cooldown: 0.5,
    color: '#dcdcdc',
    bulletSpeed: 480
  },
  {
    name: "ü¶é –ì–µ–∫–∫–æ–Ω",
    cost: 27,
    range: 2.5,
    damage: 1,
    cooldown: 0.2,
    color: '#a0f5c4',
    bulletSpeed: 500,
    dot: {
      type: "poison",
      dps: 30,
      stackDuration: 10,
      maxStacks: 50,
      multiDps: true,
      multiStacks: true
    }
  },
  {
    name: "ü¶ú –ü–æ–ø—É–≥–∞–π—á–∏–∫",
    cost: 28,
    range: 4.0,
    damage: 9,
    cooldown: 0.15,
    color: '#ffe3ac',
    bulletSpeed: 800
  },
  {
    name: "ü¶â –°–æ–≤—ë–Ω–æ–∫",
    cost: 32,
    range: 3,
    damage: 2,
    cooldown: 0.10,
    color: '#ccf1ff',
    bulletSpeed: 1,
    laser: true
  },

  // üåÄ –°–†–ï–î–ù–ò–ô –°–ï–ì–ú–ï–ù–¢ (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ)
  {
    name: "ü¶ä –õ–∏—Å–∞",
    cost: 60,
    range: 3.5,
    damage: 75,
    cooldown: 0.9,
    color: '#ffa64d',
    bulletSpeed: 1000
  },
  {
    name: "ü¶î –Å–∂",
    cost: 65,
    range: 4,
    damage: 1,
    cooldown: 0.20,
    color: '#8ee5a2',
    bulletSpeed: 700,
    dot: {
      type: "poison",
      dps: 80,
      stackDuration: 4,
      maxStacks: 10,
      multiDps: true,
      multiStacks: true
    }
  },
  {
    name: "ü¶Ö –û—Ä—ë–ª",
    cost: 70,
    range: 5.0,
    damage: 3,
    cooldown: 0.05,
    color: '#b7b7ff',
    bulletSpeed: 5,
    laser: true
  },
  {
    name: "ü¶ò –ö–µ–Ω–≥—É—Ä—É",
    cost: 75,
    range: 3.0,
    damage: 50,
    cooldown: 0.08,
    color: '#ffcfde',
    bulletSpeed: 1600
  },

  // üî• –£–õ–¨–¢–†–ê –î–û–†–û–ì–ò–ï (–ª–µ–π—Ç-–≥–µ–π–º)
  {
    name: "ü¶ñ –†–µ–∫—Å",
    cost: 240,
    range: 6.0,
    damage: 350,
    cooldown: 1.3,
    color: '#ff2f2f',
    bulletSpeed: 1600
  },
  {
    name: "üêÜ –ì–µ–ø–∞—Ä–¥",
    cost: 260,
    range: 2.5,
    damage: 95,
    cooldown: 0.02,
    color: '#ffc700',
    bulletSpeed: 2800
  },
  {
    name: "üêâ –î—Ä–∞–∫–æ–Ω",
    cost: 280,
    range: 5,
    damage: 20,
    cooldown: 0.01,
    color: '#7b2fff',
    bulletSpeed: 12,
    laser: true
  },
  {
    name: "ü¶Ç –°–∫–æ—Ä–ø–∏–æ–Ω",
    cost: 800,
    range: 4.0,
    damage: 80,
    cooldown: 0.15,
    color: '#00f5ff',
    bulletSpeed: 1400,
    dot: {
      type: "poison",
      dps: 800,
      stackDuration: 6,
      maxStacks: 250,
      multiDps: true,
      multiStacks: true
    }
  }
];

// cost         - —Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –±–∞—à–Ω—é (–≤ –º–æ–Ω–µ—Ç–∞—Ö)
// range        - –¥–∞–ª—å–Ω–æ—Å—Ç—å –ø–æ—Ä–∞–∂–µ–Ω–∏—è (–≤ –∫–ª–µ—Ç–∫–∞—Ö —Å–µ—Ç–∫–∏, CELL_SIZE = 1.0)
// damage       - —É—Ä–æ–Ω –æ–¥–Ω–æ–π –∞—Ç–∞–∫–æ–π (–ø—É–ª–µ–π –∏–ª–∏ –∏–º–ø—É–ª—å—Å–æ–º –ª–∞–∑–µ—Ä–∞)
// cooldown     - –≤—Ä–µ–º—è –º–µ–∂–¥—É –≤—ã—Å—Ç—Ä–µ–ª–∞–º–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–º–µ–Ω—å—à–µ = –±—ã—Å—Ç—Ä–µ–µ)
// color        - —Ü–≤–µ—Ç –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞ –ø–æ–ª–µ
// bulletSpeed  - —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ (–≤ –∫–ª–µ—Ç–∫–∞—Ö/—Å–µ–∫—É–Ω–¥—É)
// laser        - –µ—Å–ª–∏ true, —ç—Ç–æ –ª–∞–∑–µ—Ä–Ω–∞—è –±–∞—à–Ω—è: –Ω–∞–Ω–æ—Å–∏—Ç —É—Ä–æ–Ω –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –±–µ–∑ –ø–æ–ª—ë—Ç–∞ —Å–Ω–∞—Ä—è–¥–∞

// dot.type         - —Ç–∏–ø DOT-—ç—Ñ—Ñ–µ–∫—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "poison" ‚Äî —è–¥)
// dot.dps          - —É—Ä–æ–Ω –≤ —Å–µ–∫—É–Ω–¥—É, –Ω–∞–Ω–æ—Å–∏–º—ã–π –∫–∞–∂–¥—ã–º —Å—Ç–∞–∫–æ–º
// dot.stackDuration- –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –æ–¥–Ω–æ–≥–æ —Å—Ç–µ–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
// dot.maxStacks    - –º–∞–∫—Å–∏–º—É–º –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç–∞–∫–æ–≤ –Ω–∞ –≤—Ä–∞–≥–µ
// dot.multiDps     - –µ—Å–ª–∏ true, dps –æ—Ç –∫–∞–∂–¥–æ–≥–æ —Å—Ç–∞–∫–∞ —Å—É–º–º–∏—Ä—É–µ—Ç—Å—è (–∫–∞–∂–¥—ã–π —Å—Ç–∞–∫ –¥–æ–±–∞–≤–ª—è–µ—Ç —É—Ä–æ–Ω)
// dot.multiStacks  - –µ—Å–ª–∏ true, —Å—Ç–∞–∫–∏ –º–æ–≥—É—Ç –Ω–∞–∫–∞–ø–ª–∏–≤–∞—Ç—å—Å—è (–∏–Ω–∞—á–µ –Ω–æ–≤—ã–π –∑–∞–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ä—ã–π)


const waveData = [
  { enemies: [ {e:0, n:12, d:0.2} ] },
  { enemies: [ {e:0, n:9, d:0.5}, {e:1, n:4, d:0.066} ] },
  { enemies: [ {e:0, n:11, d:0.06}, {e:1, n:5, d:0.04} ] },
  { enemies: [ {e:0, n:13, d:0.53}, {e:1, n:6, d:0.62} ] },
  // –í–æ–ª–Ω–∞ 5
  { enemies: [ {e:0, n:15, d:0.4}, {e:1, n:10, d:0.45}, {e:2, n:1, d:2.0} ] },

  { enemies: [ {e:0, n:16, d:0.39}, {e:1, n:11, d:0.44}, {e:2, n:2, d:1.9} ] },
  { enemies: [ {e:0, n:17, d:0.38}, {e:1, n:12, d:0.43}, {e:2, n:3, d:1.8} ] },
  { enemies: [ {e:0, n:18, d:0.37}, {e:1, n:13, d:0.42}, {e:2, n:4, d:1.7} ] },
  { enemies: [ {e:0, n:19, d:0.36}, {e:1, n:14, d:0.41}, {e:2, n:5, d:1.6} ] },
  // –í–æ–ª–Ω–∞ 10
  { enemies: [ {e:1, n:18, d:0.35}, {e:2, n:10, d:1.3}, {e:3, n:1, d:3.0} ] },

  { enemies: [ {e:1, n:19, d:0.35}, {e:2, n:10, d:1.28} ] },
  { enemies: [ {e:1, n:20, d:0.34}, {e:2, n:11, d:1.26} ] },
  { enemies: [ {e:1, n:21, d:0.34}, {e:2, n:11, d:1.24} ] },
  { enemies: [ {e:1, n:22, d:0.33}, {e:2, n:12, d:1.22} ] },
  // –í–æ–ª–Ω–∞ 15
  { enemies: [ {e:1, n:23, d:0.33}, {e:2, n:12, d:1.2}, {e:3, n:1, d:3.0} ] },

  { enemies: [ {e:1, n:24, d:0.32}, {e:2, n:13, d:1.18} ] },
  { enemies: [ {e:1, n:25, d:0.32}, {e:2, n:13, d:1.16} ] },
  { enemies: [ {e:1, n:26, d:0.31}, {e:2, n:14, d:1.14} ] },
  { enemies: [ {e:1, n:27, d:0.31}, {e:2, n:14, d:1.12} ] },
  // –í–æ–ª–Ω–∞ 20
  { enemies: [ {e:1, n:22, d:0.26}, {e:2, n:20, d:0.7}, {e:4, n:4, d:1.2}, {e:3, n:2, d:3.0} ] },

  { enemies: [ {e:1, n:22, d:0.26}, {e:2, n:20, d:0.69}, {e:4, n:4, d:1.2} ] },
  { enemies: [ {e:1, n:23, d:0.26}, {e:2, n:21, d:0.67}, {e:4, n:4, d:1.2} ] },
  { enemies: [ {e:1, n:23, d:0.25}, {e:2, n:21, d:0.66}, {e:4, n:4, d:1.2} ] },
  { enemies: [ {e:1, n:24, d:0.25}, {e:2, n:22, d:0.64}, {e:4, n:4, d:1.2} ] },
  // –í–æ–ª–Ω–∞ 25
  { enemies: [ {e:1, n:24, d:0.25}, {e:2, n:22, d:0.62}, {e:4, n:5, d:1.2}, {e:3, n:2, d:3.0} ] },

  { enemies: [ {e:1, n:25, d:0.25}, {e:2, n:23, d:0.61}, {e:4, n:5, d:1.2} ] },
  { enemies: [ {e:1, n:25, d:0.25}, {e:2, n:23, d:0.59}, {e:4, n:5, d:1.2} ] },
  { enemies: [ {e:1, n:26, d:0.24}, {e:2, n:24, d:0.58}, {e:4, n:5, d:1.2} ] },
  { enemies: [ {e:1, n:26, d:0.24}, {e:2, n:24, d:0.56}, {e:4, n:5, d:1.2} ] },
  // –í–æ–ª–Ω–∞ 30
  { enemies: [ {e:1, n:25, d:0.2}, {e:2, n:25, d:0.6}, {e:4, n:7, d:0.8}, {e:5, n:6, d:1.5} ] },

  { enemies: [ {e:1, n:25, d:0.2}, {e:2, n:25, d:0.6}, {e:4, n:7, d:0.8}, {e:5, n:6, d:1.5} ] },
  { enemies: [ {e:1, n:25, d:0.2}, {e:2, n:26, d:0.6}, {e:4, n:8, d:0.8}, {e:5, n:6, d:1.5} ] },
  { enemies: [ {e:1, n:26, d:0.2}, {e:2, n:26, d:0.6}, {e:4, n:8, d:0.8}, {e:5, n:6, d:1.5} ] },
  { enemies: [ {e:1, n:26, d:0.2}, {e:2, n:27, d:0.6}, {e:4, n:8, d:0.8}, {e:5, n:6, d:1.5} ] },
  // –í–æ–ª–Ω–∞ 35
  { enemies: [ {e:1, n:26, d:0.2}, {e:2, n:27, d:0.6}, {e:4, n:8, d:0.8}, {e:5, n:7, d:1.5} ] },

  { enemies: [ {e:1, n:27, d:0.2}, {e:2, n:28, d:0.6}, {e:4, n:9, d:0.8}, {e:5, n:7, d:1.5} ] },
  { enemies: [ {e:1, n:27, d:0.2}, {e:2, n:28, d:0.6}, {e:4, n:9, d:0.8}, {e:5, n:7, d:1.5} ] },
  { enemies: [ {e:1, n:27, d:0.2}, {e:2, n:29, d:0.6}, {e:4, n:9, d:0.8}, {e:5, n:7, d:1.5} ] },
  { enemies: [ {e:1, n:28, d:0.2}, {e:2, n:29, d:0.6}, {e:4, n:9, d:0.8}, {e:5, n:7, d:1.5} ] },
  // –í–æ–ª–Ω–∞ 40
  { enemies: [ {e:3, n:2, d:3.5}, {e:4, n:14, d:1.0}, {e:5, n:13, d:0.9} ] },

  { enemies: [ {e:3, n:30, d:3.2}, {e:4, n:14, d:1.0}, {e:5, n:130, d:0.9} ] },
  { enemies: [ {e:3, n:40, d:2.9}, {e:4, n:14, d:1.0}, {e:5, n:130, d:0.9} ] },
  { enemies: [ {e:3, n:50, d:2.6}, {e:4, n:14, d:1.0}, {e:5, n:103, d:0.9} ] },
  { enemies: [ {e:3, n:60, d:2.3}, {e:4, n:15, d:1.0}, {e:5, n:104, d:0.9} ] },
  // –í–æ–ª–Ω–∞ 45
  { enemies: [ {e:3, n:70, d:0.01}, {e:4, n:815, d:1.0}, {e:5, n:104, d:0.9} ] }
];

/*
  –í –∫–∞–∂–¥–æ–π {enemies: [...]}
    e ‚Äî –∏–Ω–¥–µ–∫—Å enemyData
    n ‚Äî —Å–∫–æ–ª—å–∫–æ —à—Ç—É–∫ –ø–æ–¥—Ä—è–¥ –≤—ã–ø—É—Å—Ç–∏—Ç—å
    d ‚Äî –∑–∞–¥–µ—Ä–∂–∫–∞ (delay, —Å–µ–∫) –º–µ–∂–¥—É —ç—Ç–∏–º —Ç–∏–ø–æ–º –≤—Ä–∞–≥–æ–≤
*/
// ===== 2. –ì–ª–∞–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ =====  
let canvas, ctx;  
let grid = [];  
let towers = [], enemies = [], bullets = [];  
let path = [];  
let money = 100;  
let health = 10;  
let selectedTowerType = null;  
let isPlacingTower = false;  
let devMode = false;  
let devLog = [];  
let placingTowerCell = null;  
let victory = false;  
let defeatCause = "";  
let buildZoneHints = [];  
let mouseGridX = null, mouseGridY = null;  

// --- –ö–û–ù–¢–†–û–õ–¨ –í–û–õ–ù –ò –°–ü–ê–í–ù–ê ---  
let lastUpdateTime = Date.now();              // —Ç–∞–π–º–µ—Ä –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
let activeSpawners = [];                      // –º–∞—Å—Å–∏–≤ –æ—á–µ—Ä–µ–¥–µ–π —Å–ø–∞–≤–Ω–∞ (–ª—é–±–æ–µ –∫–æ–ª-–≤–æ –≤–æ–ª–Ω –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)

let waveTimeoutActive = false;                // –ø–∞—É–∑–∞ –º–µ–∂–¥—É –∞–≤—Ç–æ-–≤–æ–ª–Ω–∞–º–∏
let nextWaveDelay = 3;
let wavePauseLeft = 0;

let wave = 0;                                 // –∏–Ω–¥–µ–∫—Å —Å–ª–µ–¥—É—é—â–µ–π –≤–æ–ª–Ω—ã –¥–ª—è –∑–∞–ø—É—Å–∫–∞
let gameOver = false;

// ===== 3. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =====  
function init() {  
  // 1. –°–±—Ä–æ—Å–∏–º –í–°–ï –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ!  
  towers = []; enemies = []; bullets = [];  
  money = 100; health = 10; wave = 0;      // wave = 0 —á—Ç–æ–±—ã –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å—Å—è –∫ –∑–∞–ø—É—Å–∫—É –ø–µ—Ä–≤–æ–π –≤–æ–ª–Ω—ã
  selectedTowerType = null;  
  isPlacingTower = false; placingTowerCell = null;  
  mouseGridX = mouseGridY = null;  
  buildZoneHints = [];  
  gameOver = false; victory = false; defeatCause = "";  
  activeSpawners = [];                      // —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–ø–∞–≤–Ω–µ—Ä—ã
  waveTimeoutActive = true;                 // –°—Ä–∞–∑—É —Å—Ç–∞–≤–∏–º –ø–∞—É–∑—É –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –≤–æ–ª–Ω–æ–π
  wavePauseLeft = nextWaveDelay;
  if (typeof devLog === "undefined") devLog = [];  

  canvas = document.getElementById('game');  
  if (!canvas) {  
    alert('Canvas –Ω–µ –Ω–∞–π–¥–µ–Ω!');  
    return;  
  }  
  canvas.width = CANVAS_WIDTH;  
  canvas.height = CANVAS_HEIGHT;  
  ctx = canvas.getContext('2d');  

  createEmptyGrid();  
  if (!Array.isArray(grid) || grid.length !== GRID_SIZE) {  
    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–µ—Ç–∫–∏!');  
    return;  
  }  
  generateEnemyPath();  
  if (!Array.isArray(path) || path.length < 2) {  
    alert('–ü—É—Ç—å –¥–ª—è –≤—Ä–∞–≥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–µ—Ç–∫—É!');  
    showGameOverScreen();  
    return;  
  }  
  updateUI();  
  try {  
    document.getElementById('dev-panel').style.display = devMode ? "" : "none";  
    document.getElementById('wave-timer').style.display = 'none';  
  } catch(e) {}  

  if (!canvas._tdEvents) {  
    canvas.addEventListener('mousedown', handleMouseClick);  
    canvas.addEventListener('mousemove', handleMouseMove);  
    canvas.addEventListener('mouseleave', ()=>{mouseGridX=null;mouseGridY=null;buildZoneHints=[];});  
    document.addEventListener('keydown', handleKeyDown);  
    canvas._tdEvents = true;  
  }  

  createUIButtons();

  // –ù–µ –∑–∞–ø—É—Å–∫–∞–µ–º –≤–æ–ª–Ω—É —Å—Ä–∞–∑—É ‚Äî –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –≤–æ–ª–Ω–æ–π
  waveTimeoutActive = true;
  wavePauseLeft = nextWaveDelay; // –û–±—ã—á–Ω–æ —ç—Ç–æ 3 —Å–µ–∫—É–Ω–¥—ã
  updateWaveTimerUI(Math.ceil(nextWaveDelay));
  document.getElementById('wave-timer').style.display = "";
  requestAnimationFrame(gameLoop); 

  if (devMode) {  
    setTimeout(()=>{  
      console.log('[TD] State after init:', {  
        towers, enemies, bullets,  
        grid: grid ? 'OK' : 'fail', path: path ? path.length : 0,  
        wave, money, health  
      });  
    }, 100);  
  }  
}  


// ===== 4. –°–µ—Ç–∫–∞ –∏ –º–∞—Ä—à—Ä—É—Ç =====  

function createEmptyGrid() {  
  grid = [];  
  for (let y = 0; y < GRID_SIZE; ++y) {  
    let row = [];  
    for (let x = 0; x < GRID_SIZE; ++x)  
      row.push({ tower: null, base: x === GRID_SIZE - 1 && y === GRID_SIZE - 1, blocked: false });  
    grid.push(row);  
  }  
}


// ==== –ü–æ–∏—Å–∫ –ø—É—Ç–∏ A* –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ —Å –ª–æ–≥–∞–º–∏ =====

function findPath(start, goal) {
  function toKey([x, y]) { return `${x},${y}`; }
  function heuristic(a, b) { return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]); }
  let openSet = [start];
  let gScore = {};
  let fScore = {};
  let cameFrom = {};
  gScore[toKey(start)] = 0;
  fScore[toKey(start)] = heuristic(start, goal);

  let closedSet = {};

  while (openSet.length) {
    // –ù–∞–π—Ç–∏ —É–∑–µ–ª —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º fScore –≤ openSet
    let bestIdx = 0;
    for (let i = 1; i < openSet.length; ++i)
      if ((fScore[toKey(openSet[i])]||Infinity) < (fScore[toKey(openSet[bestIdx])]||Infinity)) bestIdx = i;
    let current = openSet[bestIdx];
    openSet.splice(bestIdx, 1);
    let ckey = toKey(current);

    if (current[0] === goal[0] && current[1] === goal[1]) {
      let totalPath = [current];
      while (cameFrom[toKey(totalPath[0])])
        totalPath.unshift(cameFrom[toKey(totalPath[0])]);
      if (devMode) debugLogEvent("path_found", { from: start, to: goal, length: totalPath.length });
      return totalPath;
    }

    closedSet[ckey] = true;
    let [x, y] = current;
    let neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]]
      .map(([dx, dy]) => [x + dx, y + dy])
      .filter(([nx, ny]) =>
        nx >= 0 && nx < GRID_SIZE &&
        ny >= 0 && ny < GRID_SIZE &&
        !grid[ny][nx].blocked
      );

    for (let neighbor of neighbors) {
      let nkey = toKey(neighbor);
      if (closedSet[nkey]) continue;
      let tentative_gScore = gScore[ckey] + 1;
      if (!(nkey in gScore) || tentative_gScore < gScore[nkey]) {
        cameFrom[nkey] = current;
        gScore[nkey] = tentative_gScore;
        fScore[nkey] = gScore[nkey] + heuristic(neighbor, goal);
        if (!openSet.some(([ox, oy]) => ox === neighbor[0] && oy === neighbor[1])) {
          openSet.push(neighbor);
        }
      }
    }
  }
  if (devMode) debugLogEvent("path_fail", { from: start, to: goal });
  return [];
}

// ==== A* –¥–ª—è –≤—Ä–∞–≥–æ–≤, –æ–±—â–∏–π –ø—É—Ç—å –æ—Ç –≤—Ö–æ–¥–∞ –¥–æ –±–∞–∑—ã =====
function generateEnemyPath() {
  const start = [0, 0], goal = [GRID_SIZE - 1, GRID_SIZE - 1];
  const totalPath = findPath(start, goal);

  if (Array.isArray(totalPath) && totalPath.length > 1) {
    path = totalPath;
    if (devMode) debugLogEvent("enemy_path_updated", { length: path.length, path });
  } else {
    path = [];
    if (devMode) debugLogEvent("enemy_path_error", { path: totalPath, message: "Empty or invalid path" });
  }
}

// ==== –ü–µ—Ä–µ—Å—á—ë—Ç –º–∞—Ä—à—Ä—É—Ç–æ–≤ –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤ –ø–æ—Å–ª–µ –ø–æ—Å—Ç—Ä–æ–π–∫–∏ –±–∞—à–Ω–∏ ====
function recalcPathsForAllEnemies() {
  for (let e of enemies) {
    let current = e.path && e.path[e.pathIdx] ? e.path[e.pathIdx] : [0, 0];
    let newPath = findPath(current, [GRID_SIZE - 1, GRID_SIZE - 1]);

    if (newPath && newPath.length > 1) {
      e.path = newPath;
      e.pathIdx = 0;
      if (devMode) debugLogEvent("enemy_path_recalc", { from: current, to: [GRID_SIZE - 1, GRID_SIZE - 1], length: newPath.length });
    } else {
      if (devMode) debugLogEvent("enemy_path_recalc_fail", { from: current, to: [GRID_SIZE - 1, GRID_SIZE - 1] });
      e.path = [];
      e.pathIdx = 0;
    }
  }
}

// ===== 5. –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª =====  
function gameLoop() {  
  if (gameOver) return;  
  update();  
  draw();  
  requestAnimationFrame(gameLoop);  
}  

// ===== 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ =====  
function update() {
  let dt = getDeltaTime();
  console.log('update dt:', dt);  // <-- —Å—é–¥–∞

  updateTimers(dt);
  if (!waveTimeoutActive) {
    updateSpawners(dt);
    updateEnemies(dt);
    bullets = bullets.filter(b => b.target && b.target.hp > 0);
    updateTowersShooting(dt);
    updateTowers(dt);
    updateBullets(dt);
    handleCollisions();
    checkWaveEnd();
  }
  checkGameOver();
  checkVictoryCondition();
}


function updateTimers(dt) {  
  if (waveTimeoutActive && wavePauseLeft > 0) {  
    wavePauseLeft -= dt;  
    updateWaveTimerUI(Math.max(0, Math.ceil(wavePauseLeft)));  
    if (wavePauseLeft <= 0) {  
      waveTimeoutActive = false;  
      document.getElementById('wave-timer').style.display = "none";  
      if (wave < waveData.length) {      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –µ—â–µ –≤–æ–ª–Ω—ã
        launchWave(wave);                // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—É—é –≤–æ–ª–Ω—É —á–µ—Ä–µ–∑ —Å–ø–∞–≤–Ω–µ—Ä
        wave++;
        updateUI();
      }
    }  
  }  
}

function createSpawnerForWave(waveIndex) {
  if (!waveData[waveIndex]) return null;
  let spawnList = JSON.parse(JSON.stringify(waveData[waveIndex].enemies));
  return {
    spawnList,
    spawnIdx: 0,
    nextEnemySpawnAt: 0,
    left: spawnList.reduce((sum, e) => sum + e.n, 0),
    finished: false,
    waveIndex
  };
}

function updateSpawners(dt) {
  for (const s of activeSpawners) {
    if (s.finished) continue;
    let sl = s.spawnList;
    let idx = s.spawnIdx;
    if (idx >= sl.length) { s.finished = true; continue; }
    let entry = sl[idx];
    if (!entry) { s.finished = true; continue; }

    s.nextEnemySpawnAt -= dt;
    if (entry.n > 0 && s.nextEnemySpawnAt <= 0) {
      spawnEnemy(entry.e, s.waveIndex);
      entry.n--;
      s.left--;
      s.nextEnemySpawnAt = entry.d;
    }
    if (entry.n <= 0) s.spawnIdx++;
    if (s.left <= 0 && s.spawnIdx >= sl.length) s.finished = true;
  }
  // –ú–æ–∂–Ω–æ –ø–æ—á–∏—Å—Ç–∏—Ç—å –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –æ—á–µ—Ä–µ–¥–∏ —Ç–∞–∫:
  // activeSpawners = activeSpawners.filter(s => !s.finished);
}

function launchWave(waveIndex) {
  const spawner = createSpawnerForWave(waveIndex);
  if (spawner) activeSpawners.push(spawner);
}

function getDeltaTime() {  
  const now = Date.now();  
  const dt = (now - lastUpdateTime) / 1000;  
  lastUpdateTime = now;  
  return dt;  
}

// === –ú–∞—Å—à—Ç–∞–±–∏—Ä—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≤–æ–ª–Ω–æ–≤–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ ===

/**
 * @param {number} wave - –Ω–æ–º–µ—Ä –≤–æ–ª–Ω—ã
 * @returns {number} –º–Ω–æ–∂–∏—Ç–µ–ª—å –∑–¥–æ—Ä–æ–≤—å—è –≤—Ä–∞–≥–æ–≤
 */
function scalingHP(wave) {
  const bonus = Math.floor((wave - 1) / 5) * 150;
  return 1 + bonus;
}

/**
 * @param {number} wave
 * @returns {number} –º–Ω–æ–∂–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏
 */
function scalingSpeed(wave) {
  const bonus3 = Math.floor((wave - 1) / 3) * 0.01;
  const bonus10 = Math.floor((wave - 1) / 10) * 0.05;
  return 1 + bonus3 + bonus10;
}

/**
 * @param {number} wave
 * @returns {number} –º–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞–≥—Ä–∞–¥—ã
 */
function scalingReward(wave) {
  const bonus = Math.floor((wave - 1) / 5) * 0.10;
  return 1 + bonus;
}

/**
 * @param {number} wave
 * @returns {number} –º–Ω–æ–∂–∏—Ç–µ–ª—å —É—Ä–æ–Ω–∞
 */
function scalingDamage(wave) {
  const bonus = Math.floor((wave - 1) / 10);
  return 1 + bonus;
}

/**
 * @param {number} wave
 * @returns {number} –æ–±—â–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å
 */
function scalingAll(wave) {
  const bonus = Math.floor((wave - 1) / 10) * 0.20;
  return 1 + bonus;
}

/**
 * –°–ø–∞–≤–Ω –≤—Ä–∞–≥–∞ —Å —É—á—ë—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
 * @param {number} eidx - —Ç–∏–ø –≤—Ä–∞–≥–∞
 * @param {number} waveIndex - –∏–Ω–¥–µ–∫—Å –≤–æ–ª–Ω—ã (0-based)
 */
function spawnEnemy(eidx, waveIndex) {
  try {
    if (!Array.isArray(path) || path.length < 2) {
      if (devMode) console.warn("[spawnEnemy] –û—Ç–º–µ–Ω–µ–Ω–æ ‚Äî –Ω–µ—Ç –ø—É—Ç–∏");
      return;
    }

    const econf = enemyData[eidx];
    if (!econf) {
      console.error(`[spawnEnemy] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—Ä–∞–≥: ${eidx}`);
      return;
    }

    const w = waveIndex + 1;
    const allMult = scalingAll(w);

    const hpMult     = scalingHP(w)      * allMult;
    const speedMult  = scalingSpeed(w)   * allMult;
    const rewardMult = scalingReward(w)  * allMult;
    const damageMult = scalingDamage(w)  * allMult;

    const scaledConf = {
      ...econf,
      hp: Math.round(econf.hp * hpMult),
      speed: Math.round(econf.speed * speedMult),
      reward: Math.round(econf.reward * rewardMult),
      damage: Math.floor(econf.damage * damageMult) // —É—Ä–æ–Ω –æ–∫—Ä—É–≥–ª—è–µ–º –≤–Ω–∏–∑
    };

    const enemy = new Enemy([...path], scaledConf, eidx);
    enemy.dotEffects = [];
    enemies.push(enemy);

    if (devMode) debugLogEvent("enemy_spawned", { eidx, wave: w, conf: scaledConf });

  } catch (err) {
    console.error("[spawnEnemy] –û—à–∏–±–∫–∞:", err);
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –≤–æ–ª–Ω—ã
 */
function checkWaveEnd() {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Å–ø–∞–≤–Ω–µ—Ä—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã, –Ω–µ—Ç –≤—Ä–∞–≥–æ–≤, –∏–≥—Ä–∞ –Ω–µ –æ–∫–æ–Ω—á–µ–Ω–∞ –∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–∞–π–º–∞—É—Ç–∞ –≤–æ–ª–Ω—ã
  const allSpawnersDone = activeSpawners.every(s => s.finished);
  if (
    allSpawnersDone &&
    enemies.length === 0 &&
    wave < waveData.length &&
    !gameOver &&
    !waveTimeoutActive
  ) {
    waveTimeoutActive = true;
    wavePauseLeft = nextWaveDelay;
    updateWaveTimerUI(nextWaveDelay);

    const timerEl = document.getElementById('wave-timer');
    if (timerEl) {
      timerEl.style.display = "block";  // –õ—É—á—à–µ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å block –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏
    }
  }
}

/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI —Ç–∞–π–º–µ—Ä–∞ –≤–æ–ª–Ω—ã
 * @param {number} secLeft - —Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –≤–æ–ª–Ω—ã
 */
function updateWaveTimerUI(secLeft) {
  const el = document.getElementById('wave-timer');
  if (el) {
    el.textContent = `–°–ª–µ–¥—É—é—â–∞—è –≤–æ–ª–Ω–∞: ${secLeft} —Å–µ–∫.`;
  }
}


/**
 * –û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤ (–¥–≤–∏–∂–µ–Ω–∏–µ, —ç—Ñ—Ñ–µ–∫—Ç—ã, —Å–º–µ—Ä—Ç—å)
 * @param {number} dt - –¥–µ–ª—å—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
 */
function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; --i) {
    const e = enemies[i];

    // === DOT (—è–¥, –æ–∂–æ–≥) ===
    for (let j = e.dotEffects.length - 1; j >= 0; --j) {
      const eff = e.dotEffects[j];
      e.hp -= eff.dps * eff.stacks * dt;

      eff.expires = eff.expires.map(t => t - dt).filter(t => t > 0);
      eff.stacks = eff.expires.length;

      if (eff.stacks <= 0) e.dotEffects.splice(j, 1);
    }

    // === –°–º–µ—Ä—Ç—å ===
    if (e.hp <= 0 || isNaN(e.hp)) {
      money += e.conf.reward || 0;
      enemies.splice(i, 1);
      if (typeof updateUI === "function") updateUI();
      continue;
    }

    // === –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—É—Ç–∏ ===
    if (!Array.isArray(e.path) || e.path.length < 2 || e.pathIdx >= e.path.length - 1) {
      const cx = Math.floor(e.x / CELL_SIZE);
      const cy = Math.floor(e.y / CELL_SIZE);
      const newPath = findPath([cx, cy], [GRID_SIZE - 1, GRID_SIZE - 1]);

      if (Array.isArray(newPath) && newPath.length > 1) {
        e.path = newPath;
        e.pathIdx = 0;
        e.progress = 0;
        if (devMode) debugLogEvent("enemy_repath_success", { from: [cx, cy], newLen: newPath.length });
      } else {
        if (devMode) debugLogEvent("enemy_stuck", { at: [cx, cy], reason: "no path" });
        continue;
      }
    }
    
    // === –î–≤–∏–∂–µ–Ω–∏–µ ===
    const speedPerSec = e.conf.speed / 100;
    e.progress += dt * speedPerSec;

    while (e.progress >= 1 && e.pathIdx < e.path.length - 1) {
      e.progress -= 1;
      e.pathIdx++;
    }

    // === –î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –±–∞–∑—ã ===
    if (e.pathIdx >= e.path.length - 1) {
      health -= e.conf.damage;
      if (devMode) debugLogEvent('enemy_base', {
        eidx: e.type,
        damage: e.conf.damage,
        wave,
        health
      });
      enemies.splice(i, 1);
      if (typeof updateUI === "function") updateUI();
      continue;
    }

    // === –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è ===
    const [cx, cy] = e.path[e.pathIdx];
    const [nx, ny] = e.path[e.pathIdx + 1] || [cx, cy];
    const tx = cx + (nx - cx) * e.progress;
    const ty = cy + (ny - cy) * e.progress;

    e.x = tx * CELL_SIZE + CELL_SIZE / 2;
    e.y = ty * CELL_SIZE + CELL_SIZE / 2;
  }
}


/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞—à–µ–Ω (–∞–Ω–∏–º–∞—Ü–∏—è –ª–∞–∑–µ—Ä–∞)
 * @param {number} dt
 */
function updateTowers(dt) {
  for (const t of towers) {
    if (t.laserVisual) {
      t.laserVisual.show -= dt;
      if (t.laserVisual.show <= 0) {
        t.laserVisual = null;
      }
    }
  }
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã –ø—É—à–µ–∫
 * @param {number} dt
 */
function updateTowersShooting(dt) {
  for (let t of towers) {
    t.cooldown -= dt;
    if (t.cooldown <= 0) {
      const conf = towerData[t.type];
      // –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞–¥–∏—É—Å–µ
      let inRange = enemies.filter(
        e => distance(t.cx, t.cy, e.x, e.y) <= conf.range * CELL_SIZE
      );
      if (inRange.length) {
        // –°–æ—Ä—Ç–∏—Ä—É–µ–º: –¥–∞–ª—å—à–µ –ø–æ –ø—É—Ç–∏, –º–µ–Ω—å—à–µ hp
        let target = inRange.sort(
          (a, b) => b.pathIdx - a.pathIdx || a.hp - b.hp
        )[0];

        if (conf.laser) { // —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ —Ñ–ª–∞–≥—É laser, –∞ –Ω–µ –ø–æ –∏–º–µ–Ω–∏
          target.hp -= conf.damage;
          t.cooldown = conf.cooldown;

          // –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –ª–∞–∑–µ—Ä–∞
          t.laserVisual = {
            x1: t.cx,
            y1: t.cy,
            x2: target.x,
            y2: target.y,
            color: conf.color || '#0ff',
            show: 0.10 // —Å–µ–∫ –≤–∏–¥–∏–º–æ—Å—Ç–∏
          };

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–º–µ—Ä—Ç—å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –∏ –¥–∞—ë–º –Ω–∞–≥—Ä–∞–¥—É
          if (target.hp <= 0) {
            money += target.conf.reward || 0;
            let idx = enemies.indexOf(target);
            if (idx > -1) enemies.splice(idx, 1);
            if (typeof updateUI === "function") updateUI();
          }
        }
        else {
          bullets.push(new Bullet(t.cx, t.cy, target, t));
          t.cooldown = conf.cooldown;
        }
      }
    }
  }
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; --i) {
    let b = bullets[i];

    // –ï—Å–ª–∏ —Ü–µ–ª—å —É–∂–µ —É–º–µ—Ä–ª–∞ ‚Äî —É–¥–∞–ª—è–µ–º –ø—É–ª—é
    if (!b.target || b.target.hp <= 0) {
      if (devMode) debugLogEvent("bullet_removed_dead_target", { id: i });
      bullets.splice(i, 1);
      continue;
    }

    // === –†–∞–±–æ—Ç–∞ –≤ –ö–õ–ï–¢–ö–ê–• ===
    let dx = (b.target.x - b.x) / CELL_SIZE;
    let dy = (b.target.y - b.y) / CELL_SIZE;
    let dist = Math.hypot(dx, dy);

    let step = dt * (b.speed / 100); // –∫–∞–∫ —É –≤—Ä–∞–≥–æ–≤ ‚Äî –≤ –∫–ª–µ—Ç–∫–∞—Ö/—Å–µ–∫

    if (dist < step + 0.2) { // –∑–∞–ø–∞—Å ~0.2 –∫–ª–µ—Ç–∫–∏
      b.hit = true;
      b.target.hp -= b.damage;

      // ===== –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º DOT –µ—Å–ª–∏ –µ—Å—Ç—å =====
      if (b.dot) {
        applyDotEffect(b.target, b.dot);
      }

      debugLogEvent('hit', {
        tower: b.towerType,
        eidx: b.target.type,
        dmg: b.damage,
        left: b.target.hp
      });

      if (b.target.hp <= 0) {
        money += b.target.conf.reward;

        debugLogEvent('enemy_die', {
          eid: b.target.type,
          wv: wave,
          money
        });

        let idx = enemies.indexOf(b.target);
        if (idx > -1) enemies.splice(idx, 1);
        if (typeof updateUI === "function") updateUI();
      }

      bullets.splice(i, 1);
      continue;
    }

    // ===== –î–≤–∏–∂–µ–Ω–∏–µ –ø—É–ª–∏ (–≤ –ø–∏–∫—Å–µ–ª—è—Ö) =====
    b.x += (dx / dist) * step * CELL_SIZE;
    b.y += (dy / dist) * step * CELL_SIZE;

    if (devMode) debugLogEvent("bullet_move", {
      id: i,
      speed: b.speed,
      step: (step * CELL_SIZE).toFixed(2),
      dist: (dist * CELL_SIZE).toFixed(2),
      to: [b.target.x.toFixed(1), b.target.y.toFixed(1)]
    });
  }
}
function applyDotEffect(enemy, dot) {
  if (!dot) return;

  let eff = enemy.dotEffects.find(e => e.type === dot.type);

  if (!eff) {
    // –ù–æ–≤—ã–π –¥–æ—Ç-—ç—Ñ—Ñ–µ–∫—Ç
    eff = {
      type: dot.type,
      dps: dot.dps,
      stacks: 1,
      maxStacks: dot.maxStacks || 1,
      stackDuration: dot.stackDuration,
      multiDps: dot.multiDps,
      multiStacks: dot.multiStacks,
      expires: [dot.stackDuration]
    };
    enemy.dotEffects.push(eff);
  } else {
    // –£–∂–µ –µ—Å—Ç—å —Ç–∞–∫–æ–π —ç—Ñ—Ñ–µ–∫—Ç
    if (dot.multiStacks && eff.stacks < eff.maxStacks) {
      eff.stacks++;
      eff.expires.push(dot.stackDuration);
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ —Ç–∞–π–º–µ—Ä—ã
      eff.expires = eff.expires.map(() => dot.stackDuration);
    }
    if (dot.multiDps) {
      eff.dps += dot.dps;
    }
  }
}

// ===== 8. –ú—ã—à—å –∏ –±–∞—à–Ω–∏ =====  

/****
 * –ó–∞–≥–æ—Ç–æ–≤–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π, –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –≤ –±—É–¥—É—â–µ–º
 */
function handleCollisions() {
  // –ü–æ–∫–∞ –ø—É—Å—Ç–æ
}

/**
 * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –º—ã—à–∏ –ø–æ –∏–≥—Ä–æ–≤–æ–º—É –ø–æ–ª—é
 * @param {MouseEvent} e - —Å–æ–±—ã—Ç–∏–µ –º—ã—à–∏
 * @returns {boolean|undefined} - false –µ—Å–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –ü–ö–ú –¥–ª—è –æ—Ç–º–µ–Ω—ã
 */
function handleMouseClick(e) {
  if (gameOver || victory) {
    if (devMode) console.debug("[handleMouseClick] –ò–≥—Ä–∞ –∑–∞–∫–æ–Ω—á–µ–Ω–∞, –∫–ª–∏–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è");
    return;
  }
  let pos = getCellFromMouse(e);
  if (!pos) {
    if (devMode) console.debug("[handleMouseClick] –ö–ª–∏–∫ –≤–Ω–µ –ø–æ–ª—è");
    return;
  }
  let [x, y] = pos;

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ-–±–æ–∫—Å –ø–æ –±–∞—à–Ω–µ, –µ—Å–ª–∏ –Ω–µ –≤ —Ä–µ–∂–∏–º–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
  if (!isPlacingTower && grid[y][x].tower) {
    if (devMode) console.debug(`[handleMouseClick] –ü–æ–∫–∞–∑ –∏–Ω—Ñ–æ –ø–æ –±–∞—à–Ω–µ –Ω–∞ (${x},${y})`);
    showTowerInfo(grid[y][x].tower.type, x, y);
    return;
  }

  if (e.button === 2) { // –ü–ö–ú ‚Äî –æ—Ç–º–µ–Ω–∞ –≤—ã–±–æ—Ä–∞ –±–∞—à–Ω–∏ –∏ —Ä–µ–∂–∏–º–∞ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
    if (devMode) console.debug("[handleMouseClick] –ü–ö–ú ‚Äî –æ—Ç–º–µ–Ω–∞ –≤—ã–±–æ—Ä–∞ –±–∞—à–Ω–∏ –∏ —Ä–µ–∂–∏–º–∞ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞");
    selectedTowerType = null;
    isPlacingTower = false;
    placingTowerCell = null;
    updateUI();
    buildZoneHints = [];
    return false;
  }

  if (selectedTowerType === null) {
    if (devMode) console.debug("[handleMouseClick] –ë–∞—à–Ω—è –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞");
    return;
  }

  if (isCellEmpty(x, y) && canPlaceTower(x, y)) {
    if (devMode) console.debug(`[handleMouseClick] –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–∞—à–Ω–∏ —Ç–∏–ø–∞ ${selectedTowerType} –Ω–∞ (${x},${y})`);
    placeTower(x, y, selectedTowerType);
    // –†–µ–∂–∏–º —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º (–ø–æ –≤–∞—à–µ–º—É –∑–∞–º—ã—Å–ª—É)
    placingTowerCell = null;
    buildZoneHints = [];
    updateUI();
  } else {
    if (devMode) console.debug(`[handleMouseClick] –ù–µ–ª—å–∑—è –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–∞—à–Ω—é –Ω–∞ (${x},${y})`);
  }
}

/**
 * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏ –ø–æ –∏–≥—Ä–æ–≤–æ–º—É –ø–æ–ª—é
 * @param {MouseEvent} e - —Å–æ–±—ã—Ç–∏–µ –º—ã—à–∏
 */
function handleMouseMove(e) {
  if (!isPlacingTower) {
    mouseGridX = mouseGridY = null;
    buildZoneHints = [];
    if (devMode) console.debug("[handleMouseMove] –†–µ–∂–∏–º —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –≤—ã–∫–ª—é—á–µ–Ω ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã");
    return;
  }
  let pos = getCellFromMouse(e);
  if (pos) {
    mouseGridX = pos[0];
    mouseGridY = pos[1];
    buildZoneHints = [];
    let viewRange = 2;

    for (let y = Math.max(0, mouseGridY - viewRange); y <= Math.min(GRID_SIZE - 1, mouseGridY + viewRange); y++) {
      for (let x = Math.max(0, mouseGridX - viewRange); x <= Math.min(GRID_SIZE - 1, mouseGridX + viewRange); x++) {
        // –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ä—Ç –∏ —Ñ–∏–Ω–∏—à
        if ((x === 0 && y === 0) || (x === GRID_SIZE - 1 && y === GRID_SIZE - 1)) continue;
        let allowed = isCellEmpty(x, y) && canPlaceTower(x, y);
        buildZoneHints.push({ x, y, allowed });
      }
    }
    if (devMode) console.debug(`[handleMouseMove] –ü–æ–¥—Å–∫–∞–∑–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤–æ–∫—Ä—É–≥ (${mouseGridX},${mouseGridY})`);
  }
}
// ===== 9. –ü—Ä–æ–≤–µ—Ä–∫–∏ –ø—É—Ç–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º =====

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–≤–æ–±–æ–¥–Ω–∞ –ª–∏ –∫–ª–µ—Ç–∫–∞ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∞—à–Ω–∏.
 * –õ–æ–≥–∏—Ä—É–µ—Ç –∫–∞–∂–¥—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
 * @param {number} x - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ X
 * @param {number} y - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ Y
 * @returns {boolean} true, –µ—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —Å–≤–æ–±–æ–¥–Ω–∞, –∏–Ω–∞—á–µ false
 */
function isCellEmpty(x, y) {
  if (grid[y][x].blocked) {
    if (devMode) debugLogEvent('cell_blocked', { x, y });
    return false;
  }
  if (grid[y][x].tower) {
    if (devMode) debugLogEvent('cell_tower_exists', { x, y });
    return false;
  }
  for (let t of towers) {
    if (t.gridX === x && t.gridY === y) {
      if (devMode) debugLogEvent('cell_tower_in_array', { x, y });
      return false;
    }
  }
  if (devMode) debugLogEvent('cell_empty', { x, y });
  return true;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–∞—à–Ω—é –Ω–∞ –∫–ª–µ—Ç–∫—É.
 * –ó–∞–ø—Ä–µ—â–∞–µ—Ç —Å—Ç—Ä–æ–∏—Ç—å –Ω–∞ –≤—Ö–æ–¥–µ –∏ –≤—ã—Ö–æ–¥–µ.
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É, –Ω–µ –ø–µ—Ä–µ–∫—Ä–æ–µ—Ç –ª–∏ –±–∞—à–Ω—è –ø—É—Ç—å –≤—Ä–∞–≥–∞–º.
 * –õ–æ–≥–∏—Ä—É–µ—Ç –∫–∞–∂–¥–æ–µ —Ä–µ—à–µ–Ω–∏–µ.
 * @param {number} x - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ X
 * @param {number} y - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ Y
 * @returns {boolean} true, –µ—Å–ª–∏ –±–∞—à–Ω—é –º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å
 */
function canPlaceTower(x, y) {
  if ((x === 0 && y === 0) || (x === GRID_SIZE - 1 && y === GRID_SIZE - 1)) {
    if (devMode) debugLogEvent("deny_entrance_exit", { x, y });
    return false;
  }
  if (!isCellEmpty(x, y)) {
    if (devMode) debugLogEvent("not_empty", { x, y });
    return false;
  }
  
  // –í—Ä–µ–º–µ–Ω–Ω–æ –±–ª–æ–∫–∏—Ä—É–µ–º –∫–ª–µ—Ç–∫—É, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—É—Ç—å
  grid[y][x].blocked = true;
  let found = hasEnemyPath();
  if (devMode) debugLogEvent("path_check", {
    x, y,
    ok: found,
    message: found ? "–ü—É—Ç—å –µ—Å—Ç—å, —Å—Ç—Ä–æ–∏—Ç—å –º–æ–∂–Ω–æ" : "–ü—É—Ç—å –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç—Å—è, —Å—Ç—Ä–æ–∏—Ç—å –Ω–µ–ª—å–∑—è",
    towersCount: towers.length
  });
  grid[y][x].blocked = false;

  return found;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –¥–ª—è –≤—Ä–∞–≥–∞ –æ—Ç —Å—Ç–∞—Ä—Ç–∞ –¥–æ —Ñ–∏–Ω–∏—à–∞.
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–∏—Å–∫–∞ A* —Å –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–º–∏ –ø–µ—Ä–µ—Ö–æ–¥–∞–º–∏.
 * –õ–æ–≥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏.
 * @returns {boolean} true –µ—Å–ª–∏ –ø—É—Ç—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏–Ω–∞—á–µ false
 */
function hasEnemyPath() {
  const start = [0, 0];
  const goal = [GRID_SIZE - 1, GRID_SIZE - 1];

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∏: –ú–∞–Ω—Ö—ç—Ç—Ç–µ–Ω + –¥–∏–∞–≥–æ–Ω–∞–ª—å
  function heuristic([x1, y1], [x2, y2]) {
    let dx = Math.abs(x1 - x2);
    let dy = Math.abs(y1 - y2);
    // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (Octile distance)
    const D = 1;
    const D2 = Math.SQRT2;
    return D * (dx + dy) + (D2 - 2 * D) * Math.min(dx, dy);
  }

  // 8 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –¥–≤–∏–∂–µ–Ω–∏—è —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é
  const directions = [
    [1, 0, 1], [-1, 0, 1], [0, 1, 1], [0, -1, 1],   // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏, —Å—Ç–æ–∏–º–æ—Å—Ç—å 1
    [1, 1, Math.SQRT2], [1, -1, Math.SQRT2], [-1, 1, Math.SQRT2], [-1, -1, Math.SQRT2]  // –¥–∏–∞–≥–æ–Ω–∞–ª–∏, —Å—Ç–æ–∏–º–æ—Å—Ç—å sqrt(2)
  ];

  // –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–æ—Å–µ—â—ë–Ω–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫
  let closedSet = new Set();
  // –û—á–µ—Ä–µ–¥—å —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º (min-heap –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π)
  // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Å—Å–∏–≤ –∏ –ø–æ–∏—Å–∫ min –∫–∞–∂–¥—ã–π —Ä–∞–∑ (–Ω–µ–¥–æ—Ä–æ–≥–æ –ø—Ä–∏ –Ω–µ–±–æ–ª—å—à–æ–º GRID_SIZE)
  let openSet = [{ pos: start, g: 0, f: heuristic(start, goal) }];
  // –ö–∞—Ä—Ç–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—É—Ç–∏
  let cameFrom = new Map();

  function posToKey([x, y]) {
    return `${x},${y}`;
  }

  while (openSet.length > 0) {
    // –ù–∞–π—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º f
    openSet.sort((a, b) => a.f - b.f);
    let current = openSet.shift();
    let [cx, cy] = current.pos;

    if (cx === goal[0] && cy === goal[1]) {
      if (devMode) debugLogEvent("a_star_pass", { cx, cy, result: "finish reached" });
      return true;
    }

    closedSet.add(posToKey(current.pos));

    for (let [dx, dy, cost] of directions) {
      let nx = cx + dx;
      let ny = cy + dy;
      if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) continue;
      if (grid[ny][nx].blocked) continue;
      if (closedSet.has(posToKey([nx, ny]))) continue;

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "—Å–∫–≤–æ–∑–Ω—ã–µ" –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–æ—Ö–æ–¥—ã –º–µ–∂–¥—É —É–≥–ª–∞–º–∏ –±–∞—à–µ–Ω:
      // –ï—Å–ª–∏ –¥–≤–∏–≥–∞–µ–º—Å—è –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏, –Ω–∞–¥–æ —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã
      if (dx !== 0 && dy !== 0) {
        if (grid[cy][nx].blocked || grid[ny][cx].blocked) continue;
      }

      let tentative_g = current.g + cost;
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —ç—Ç–æ—Ç —É–∑–µ–ª –≤ openSet —Å –º–µ–Ω—å—à–µ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é
      let existingNode = openSet.find(n => n.pos[0] === nx && n.pos[1] === ny);
      if (existingNode && tentative_g >= existingNode.g) {
        continue;
      }

      cameFrom.set(posToKey([nx, ny]), current.pos);
      if (existingNode) {
        existingNode.g = tentative_g;
        existingNode.f = tentative_g + heuristic([nx, ny], goal);
      } else {
        openSet.push({
          pos: [nx, ny],
          g: tentative_g,
          f: tentative_g + heuristic([nx, ny], goal)
        });
      }
    }
  }

  if (devMode) debugLogEvent("a_star_fail", { result: "no path for enemy" });
  return false;
}

/**
 * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –±–∞—à–Ω—é –Ω–∞ –ø–æ–ª–µ, –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ä–µ—Å—É—Ä—Å—ã, –∏ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ—Ç –ø—É—Ç–∏ –≤—Ä–∞–≥–æ–≤.
 * –õ–æ–≥–∏—Ä—É–µ—Ç –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —ç—Ç–∞–ø—ã —É—Å—Ç–∞–Ω–æ–≤–∫–∏.
 * @param {number} x - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ X
 * @param {number} y - –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–æ Y
 * @param {string} type - –¢–∏–ø –±–∞—à–Ω–∏
 */
function placeTower(x, y, type) {
  let conf = towerData[type];
  if (money < conf.cost) {
    if (devMode) debugLogEvent('not_enough_money', { x, y, type, money });
    return;
  }

  towers.push(new Tower(x, y, type));
  grid[y][x].tower = towers[towers.length - 1];
  grid[y][x].blocked = true; // –¢–µ–ø–µ—Ä—å –±–∞—à–Ω—è –±–ª–æ–∫–∏—Ä—É–µ—Ç –ø—É—Ç—å
  money -= conf.cost;

  if (devMode) debugLogEvent('tower_built', {
    x, y, type,
    cost: conf.cost,
    money_left: money,
    total_towers: towers.length
  });

  generateEnemyPath();
  recalcPathsForAllEnemies(); // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–æ–≤ –¥–ª—è –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤

  if (devMode) {
    debugLogEvent('path_updated_after_tower', {
      new_path: path.map(pair => ({ x: pair[0], y: pair[1] }))
    });
  }

  updateUI();
}


// ===== 10. –ö–ª–∞—Å—Å—ã/—Ñ–∞–±—Ä–∏–∫–∏ =====  

function Tower(x, y, type) {  
  return {  
    gridX: x, gridY: y, type,  
    cx: x * CELL_SIZE + CELL_SIZE / 2,  
    cy: y * CELL_SIZE + CELL_SIZE / 2,  
    cooldown: 0  
  };
} 

function Enemy(pth, conf, type) {
  let x = (Array.isArray(pth) && pth.length) ? pth[0][0] * CELL_SIZE + CELL_SIZE / 2 : 0;
  let y = (Array.isArray(pth) && pth.length) ? pth[0][1] * CELL_SIZE + CELL_SIZE / 2 : 0;
  return {
    path: pth,
    pathIdx: 0,
    conf,
    type,
    hp: conf.hp,
    x,
    y,
    initPos: 1,
    progress: 0,
    dotEffects: [] // <-- –í–ê–ñ–ù–û: —Ç–µ–ø–µ—Ä—å —É –∫–∞–∂–¥–æ–≥–æ –≤—Ä–∞–≥–∞ –≤—Å–µ–≥–¥–∞ –µ—Å—Ç—å –º–∞—Å—Å–∏–≤ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ DOT
  };
}


function Bullet(x, y, target, tower) {
  let conf = towerData[tower.type];
  let bullet = {
    x, y, target,
    damage: conf.damage,
    speed: conf.bulletSpeed,
    color: conf.color,
    towerType: tower.type,
    hit: false
  };
  // --- –ü–µ—Ä–µ–¥–∞–µ–º dot –∏–∑ towerData (–µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å) ---
  if (conf.dot) bullet.dot = conf.dot;
  return bullet;
}


// ===== 11. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ =====  

function draw() {
  // –õ–æ–≥: –Ω–∞—á–∞–ª–æ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
  console.log("jsdot: draw() start");

  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  drawGrid();
  drawBuildHints();
  drawTowerRanges();
  drawTowers();

  // === –û–¢–†–∏—Å–û–í–ö–ê –õ–ê–ó–ï–†–ù–´–• –õ–£–ß–ï–ô ===
  // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –∫–µ—à–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ–¥–∏–Ω —Ä–∞–∑
  const nowSec = performance.now() / 1000;

  for (let t of towers) {
    if (t.laserVisual && t.laserVisual.show > 0) {
      let conf = towerData[t.type] || {};
      let freq = conf.bulletSpeed || 15;
      let phase = (nowSec * freq) % 1;

      if (phase < 0.5) {
        // –£–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é —Å —É—á—ë—Ç–æ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
        let alpha = 0.6 + 0.4 * Math.min(t.laserVisual.show * 10, 1);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = t.laserVisual.color || "#f00";
        ctx.lineWidth = (conf.name && conf.name.startsWith('LA2')) ? 8 : 4;
        ctx.shadowColor = t.laserVisual.color || "#f00";
        ctx.shadowBlur = 16;

        ctx.beginPath();
        ctx.moveTo(t.laserVisual.x1, t.laserVisual.y1);
        ctx.lineTo(t.laserVisual.x2, t.laserVisual.y2);
        ctx.stroke();

        ctx.restore();

        console.log(`jsdot: draw laser from tower ${t.type} with alpha ${alpha.toFixed(2)}`);
      }
    }
  }

  drawEnemies();
  drawBullets();

  if (devMode) debugDrawPath(path);

  if (victory) showVictoryScreen();
  if (gameOver) showGameOverScreen();

  // –õ–æ–≥: –∫–æ–Ω–µ—Ü –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
  console.log("jsdot: draw() end");
}

// –ê–Ω–∏–º–∞—Ü–∏—è ‚Äî –≤—ã–∑—ã–≤–∞–µ–º draw –≤ —Ü–∏–∫–ª–µ —á–µ—Ä–µ–∑ requestAnimationFrame
function animationLoop() {
  draw();
  requestAnimationFrame(animationLoop);
}
// –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏ –æ–¥–∏–Ω —Ä–∞–∑ (–≥–¥–µ-—Ç–æ –≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã)
// animationLoop();

function drawGrid() {
  ctx.save();
  for (let y = 0; y < GRID_SIZE; ++y) {
    for (let x = 0; x < GRID_SIZE; ++x) {
      ctx.strokeStyle =
        x === 0 && y === 0 ? "#e3ed7a" :
        x === GRID_SIZE - 1 && y === GRID_SIZE - 1 ? "#ffae00" :
        "#3a3a3a";
      ctx.lineWidth = 2;
      ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

      if (grid[y][x].blocked) {
        ctx.fillStyle = "#593045";
        ctx.globalAlpha = 0.2;
        ctx.fillRect(x * CELL_SIZE + 3, y * CELL_SIZE + 3, CELL_SIZE - 6, CELL_SIZE - 6);
        ctx.globalAlpha = 1.0;
      }
    }
  }
  ctx.restore();

  if (devMode) {
    ctx.save();
    ctx.strokeStyle = "#31aec8";
    ctx.lineWidth = 5;
    ctx.globalAlpha = 0.21;
    ctx.beginPath();
    for (let i = 0; i < path.length; ++i) {
      let [x, y] = path[i];
      if (i === 0) ctx.moveTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2);
      else ctx.lineTo(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function drawBuildHints() {
  if (!buildZoneHints || !buildZoneHints.length) return;

  for (let hint of buildZoneHints) {
    let { x, y, allowed } = hint;
    ctx.save();

    let notEnoughMoney = selectedTowerType != null && money < (towerData[selectedTowerType]?.cost || 99999);

    if (allowed && selectedTowerType != null && !notEnoughMoney) {
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = towerData[selectedTowerType].color;
    } else if (allowed && selectedTowerType != null && notEnoughMoney) {
      let t = Date.now() / 105;
      ctx.globalAlpha = 0.4 + 0.5 * Math.abs(Math.sin(t));
      ctx.fillStyle = "rgba(255,25,50,1)";
    } else {
      ctx.globalAlpha = 0.24;
      ctx.fillStyle = "#ef2b2b";
    }

    ctx.beginPath();
    ctx.rect(x * CELL_SIZE + 2, y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    if (allowed && selectedTowerType != null) {
      let tconf = towerData[selectedTowerType];
      ctx.save();
      ctx.strokeStyle = "#00ff79";
      ctx.globalAlpha = 0.10;
      ctx.beginPath();
      ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, tconf.range * CELL_SIZE, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  if (isPlacingTower && mouseGridX !== null && mouseGridY !== null) {
    ctx.save();
    ctx.globalAlpha = 0.5;
    let canBuild = isCellEmpty(mouseGridX, mouseGridY) && canPlaceTower(mouseGridX, mouseGridY);
    ctx.strokeStyle = canBuild ? "#36ef97" : "#b71010";
    ctx.lineWidth = 4;
    ctx.strokeRect(mouseGridX * CELL_SIZE + 3, mouseGridY * CELL_SIZE + 3, CELL_SIZE - 6, CELL_SIZE - 6);
    ctx.globalAlpha = 1;
    ctx.restore();

    if (selectedTowerType != null) {
      let tconf = towerData[selectedTowerType];
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.beginPath();
      ctx.arc(mouseGridX * CELL_SIZE + CELL_SIZE / 2, mouseGridY * CELL_SIZE + CELL_SIZE / 2, tconf.range * CELL_SIZE, 0, 2 * Math.PI);
      ctx.fillStyle = tconf.color;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }
}

function drawTowerRanges() {
  if (!devMode) return;
  for (let t of towers) {
    let conf = towerData[t.type];
    ctx.save();
    ctx.beginPath();
    ctx.arc(t.cx, t.cy, conf.range * CELL_SIZE, 0, 2 * Math.PI);
    ctx.globalAlpha = 0.13;
    ctx.fillStyle = conf.color;
    ctx.fill();
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
}

function drawTowers() {
  for (let t of towers) {
    let conf = towerData[t.type];
    ctx.beginPath();
    ctx.arc(t.cx, t.cy, CELL_SIZE * 0.33, 0, 2 * Math.PI);
    ctx.fillStyle = conf.color;
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 5;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#282a3c";
    ctx.stroke();

    // --- –ü–æ–¥–ø–∏—Å—å: —á—ë—Ä–Ω–∞—è –æ–±–≤–æ–¥–∫–∞ + —Ç–µ–Ω—å + —Ü–≤–µ—Ç ---
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 4;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#000";
    ctx.strokeText(conf.name, t.cx, t.cy + CELL_SIZE / 2 - 4);
    ctx.shadowBlur = 0;
    ctx.fillStyle = conf.color;
    ctx.fillText(conf.name, t.cx, t.cy + CELL_SIZE / 2 - 4);
  }
}
function drawEnemies() {
  for (let e of enemies) {
    if (isNaN(e.x) || isNaN(e.y)) continue;
    ctx.save();

    // –¢–µ–ª–æ –≤—Ä–∞–≥–∞
    ctx.beginPath();
    ctx.arc(e.x, e.y, CELL_SIZE * 0.26, 0, 2 * Math.PI);
    ctx.fillStyle = e.conf.color || "#ddd";
    ctx.globalAlpha = 0.86;
    ctx.fill();
    ctx.strokeStyle = "#4a172a";
    ctx.stroke();

    // HP –±–∞—Ä
    let hpRatio = e.hp / e.conf.hp;
    const hpBarWidth = CELL_SIZE * 0.34;
    const hpBarHeight = 5;
    const hpBarX = e.x - hpBarWidth / 2;
    const hpBarY = e.y + CELL_SIZE * 0.13;

    ctx.fillStyle = "#ed3838"; 
    ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

    ctx.fillStyle = "#7de17b";
    ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);

    ctx.strokeStyle = "#111";
    ctx.lineWidth = 1;
    ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

    // –ò–º—è –≤—Ä–∞–≥–∞
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.fillText(e.conf.name, e.x, e.y - CELL_SIZE * 0.28);

    // –ß–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ HP —Å–ø—Ä–∞–≤–∞ –æ—Ç –ø–æ–ª–æ—Å–∫–∏
    ctx.font = "10px monospace";
    ctx.textAlign = "left";
    ctx.fillStyle = "#fff";
    const hpText = `${Math.ceil(e.hp)} / ${e.conf.hp}`;
    ctx.fillText(hpText, hpBarX + hpBarWidth + 4, hpBarY + hpBarHeight);

    ctx.restore();

    // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏ –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –∏–ª–∏ —É–±—Ä–∞—Ç—å
    // console.log(`jsdot: drew enemy ${e.conf.name} HP ${e.hp.toFixed(1)}/${e.conf.hp}`);
  }
}


function drawBullets() {
  for (let b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 6, 0, 2 * Math.PI);
    ctx.fillStyle = b.color || "#fff";
    ctx.fill();

    ctx.strokeStyle = "#222";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(b.x, b.y, 10, 0, 2 * Math.PI);
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = b.color || "#fff";
    ctx.stroke();
    ctx.globalAlpha = 1.0;
  }
}

// ===== 12. UI =====  

// –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–Ω–¥–µ–∫—Å—ã –±–∞—à–µ–Ω –ø–æ —Ü–µ–Ω–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ø–æ–∏—Å–∫–∞ —Å–ª–µ–¥—É—é—â–µ–π/–ø—Ä–µ–¥—ã–¥—É—â–µ–π –±–∞—à–Ω–∏
const towerCostOrder = towerData
  .map((t, i) => ({ i, cost: t.cost }))  // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ {–∏–Ω–¥–µ–∫—Å, —Ü–µ–Ω–∞}
  .sort((a, b) => a.cost - b.cost)       // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
  .map(t => t.i);                        // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∏–Ω–¥–µ–∫—Å—ã –±–∞—à–µ–Ω

// –ü–æ–ª—É—á–∏—Ç—å –∏–Ω–¥–µ–∫—Å —Å–ª–µ–¥—É—é—â–µ–π/–ø—Ä–µ–¥—ã–¥—É—â–µ–π –±–∞—à–Ω–∏ –ø–æ —Ü–µ–Ω–µ
function getNextTowerType(type) {
  let idx = towerCostOrder.indexOf(type);
  // –ï—Å–ª–∏ —Ç–µ–∫—É—â–µ–π –±–∞—à–Ω–∏ –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ –∏–ª–∏ —ç—Ç–æ —Å–∞–º–∞—è –¥–æ—Ä–æ–≥–∞—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null
  if (idx === -1 || idx === towerCostOrder.length - 1) return null;
  return towerCostOrder[idx + 1];
}

function getPrevTowerType(type) {
  let idx = towerCostOrder.indexOf(type);
  // –ï—Å–ª–∏ –±–∞—à–Ω—è –ø–µ—Ä–≤–∞—è –∏–ª–∏ –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ ‚Äî null
  if (idx <= 0) return null;
  return towerCostOrder[idx - 1];
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–≤–µ—Ç "—Å–≤–µ—Ç–ª—ã–º" –ø–æ —Ñ–æ—Ä–º—É–ª–µ —è—Ä–∫–æ—Å—Ç–∏
function isLight(color) {
  if (!color) return false;
  color = color.replace('#', '');  // –£–±–∏—Ä–∞–µ–º # –∏–∑ —Å—Ç—Ä–æ–∫–∏ —Ü–≤–µ—Ç–∞
  let r = parseInt(color.substring(0, 2), 16);
  let g = parseInt(color.substring(2, 4), 16);
  let b = parseInt(color.substring(4, 6), 16);
  // –§–æ—Ä–º—É–ª–∞ —è—Ä–∫–æ—Å—Ç–∏ —Å —É—á—ë—Ç–æ–º –≤–æ—Å–ø—Ä–∏—è—Ç–∏—è —Ü–≤–µ—Ç–∞ —á–µ–ª–æ–≤–µ–∫–æ–º
  return (r * 0.299 + g * 0.587 + b * 0.114) > 180;
}

/**
 * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–∞—à–Ω–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ HTML —Ç–∞–±–ª–∏—Ü—ã.
 * @param {number} type - –∏–Ω–¥–µ–∫—Å —Ç–∏–ø–∞ –±–∞—à–Ω–∏ –∏–∑ towerData
 * @param {number|null} x - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–µ–π—á–∞—Å)
 * @param {number|null} y
 */
function showTowerInfo(type, x = null, y = null) {
  let conf = towerData[type];
  if (!conf) {
    console.warn(`showTowerInfo: –±–∞—à–Ω—è —Å —Ç–∏–ø–æ–º ${type} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ towerData`);
    return;
  }

  const nextType = getNextTowerType(type);
  const prevType = getPrevTowerType(type);
  const next = nextType !== null ? towerData[nextType] : null;
  const prev = prevType !== null ? towerData[prevType] : null;

  function cell(content, className = '') {
    return `<td class="${className}">${content ?? ''}</td>`;
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —è—á–µ–π–∫–∏ —Å –∑–∞—Ç–µ–Ω–µ–Ω–∏–µ–º, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
  function cellWithOpacity(val, baseClass) {
    return `<td class="${baseClass} ${val ? '' : 'dimmed'}">${val ?? ''}</td>`;
  }

  let stats = `
    <table class="tower-info-table">
      <tbody>
        <tr>
          ${cellWithOpacity(prev?.cost, 'col-left')}
          ${cell(conf.cost, 'col-center')}
          ${cellWithOpacity(next?.cost, 'col-right')}
          ${cell('–°—Ç–æ–∏–º–æ—Å—Ç—å', 'label-cell')}
        </tr>
        <tr>
          ${cellWithOpacity(prev?.range, 'col-left')}
          ${cell(conf.range, 'col-center')}
          ${cellWithOpacity(next?.range, 'col-right')}
          ${cell('–î–∞–ª—å–Ω–æ—Å—Ç—å', 'label-cell')}
        </tr>
        <tr>
          ${cellWithOpacity(prev?.damage, 'col-left')}
          ${cell(conf.damage, 'col-center')}
          ${cellWithOpacity(next?.damage, 'col-right')}
          ${cell('–£—Ä–æ–Ω', 'label-cell')}
        </tr>
        <tr>
          ${cellWithOpacity(prev ? prev.cooldown + 's' : '', 'col-left')}
          ${cell(conf.cooldown + 's', 'col-center')}
          ${cellWithOpacity(next ? next.cooldown + 's' : '', 'col-right')}
          ${cell('–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞', 'label-cell')}
        </tr>
        <tr>
          ${cellWithOpacity(prev?.bulletSpeed, 'col-left')}
          ${cell(conf.bulletSpeed, 'col-center')}
          ${cellWithOpacity(next?.bulletSpeed, 'col-right')}
          ${cell('–°–∫–æ—Ä.–ø—É–ª–∏', 'label-cell')}
        </tr>
      </tbody>
    </table>
  `;

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è –ª–∞–∑–µ—Ä–Ω—ã—Ö –±–∞—à–µ–Ω
  if (conf.laser) {
    stats += `
      <table class="tower-info-table tower-info-laser">
        <tbody>
          <tr class="tower-info-extra-row">
            <td colspan="4">–õ–∞–∑–µ—Ä–Ω–∞—è –±–∞—à–Ω—è</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center" style="color: ${conf.color}">–£—Ä–æ–Ω –∑–∞ —Ç–∏–∫</td>
            <td class="col-center">${conf.damage}</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ (—Å–µ–∫)</td>
            <td class="col-center">${conf.cooldown}</td>
          </tr>
        </tbody>
      </table>
    `;
  }

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è DOT-—ç—Ñ—Ñ–µ–∫—Ç–∞
  if (conf.dot) {
    stats += `
      <table class="tower-info-table tower-info-dot">
        <tbody>
          <tr class="tower-info-extra-row">
            <td colspan="4">DOT-—ç—Ñ—Ñ–µ–∫—Ç (${conf.dot.type})</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">–£—Ä–æ–Ω –≤ —Å–µ–∫—É–Ω–¥—É (DPS)</td>
            <td class="col-center">${conf.dot.dps}</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–¥–Ω–æ–≥–æ —Å—Ç–∞–∫–∞ (—Å–µ–∫)</td>
            <td class="col-center">${conf.dot.stackDuration}</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">–ú–∞–∫—Å–∏–º—É–º —Å—Ç–∞–∫–æ–≤</td>
            <td class="col-center">${conf.dot.maxStacks}</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">DPS —Å—É–º–º–∏—Ä—É–µ—Ç—Å—è?</td>
            <td class="col-center">${conf.dot.multiDps ? '–ù–µ—Ç' : '–î–∞'}</td>
          </tr>
          <tr>
            <td colspan="3" class="col-center">–°—Ç–∞–∫–∏ –Ω–∞–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è?</td>
            <td class="col-center">${conf.dot.multiStacks ? '–î–∞' : '–ù–µ—Ç'}</td>
          </tr>
        </tbody>
      </table>
    `;
  }

  // --- –ö–Ω–æ–ø–∫–∏ ---
  let downgradeBtn = '', upgradeBtn = '';
  if (prevType !== null && x !== null && y !== null) {
    downgradeBtn = mkBtn(`‚ñº ${prev.name} +${prev.cost}`, `downgradeTower(${x},${y})`, prev.color, true);
  }
  if (nextType !== null && x !== null && y !== null) {
    const can = money >= next.cost;
    upgradeBtn = mkBtn(`${next.name} ${next.cost} ‚ñ≤`, `upgradeTower(${x},${y})`, next.color, can);
  }
  let sellBtn = '';
  if (x !== null && y !== null) {
    let refund = Math.round(0.5 * conf.cost);
    sellBtn = `
      <button 
        onclick="sellTower(${x},${y})"
        style="
          background:#f8d23a;
          color:#49390a;
          font-weight:bold;
          min-width:100px;
          margin:0 2px;
          border:2px solid #b9a429;
          border-radius:7px;
          font-size:15px;
          box-shadow:0 0 7px #fbe17599;
          cursor:pointer;
          padding:8px 10px;
          display:inline-flex;
          align-items:center;
        "
        title="–ü—Ä–æ–¥–∞—Ç—å –±–∞—à–Ω—é –∑–∞ ${refund} –º–æ–Ω–µ—Ç"
      >
        <svg width="16" height="16" style="margin-right:5px;" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7" fill="#ede066" stroke="#af9033" stroke-width="2"/><text x="8" y="11" font-size="8" font-family="monospace" text-anchor="middle" fill="#af9033" font-weight="bold">$</text></svg>
        –ü—Ä–æ–¥–∞—Ç—å <b>${refund}</b>
      </button>
    `;
  }
  let buttons = `
    <div style="margin:10px 0;text-align:center;min-width:230px;">
      <span style="float:left;">${downgradeBtn}</span>
      <span style="display:inline-block;">
        ${sellBtn}
        <button onclick="hideTowerInfo()" style="margin-left:7px;background:#181a22;color:#fafafa;font-size:15px;border-radius:7px;padding:8px 13px;">OK</button>
      </span>
      <span style="float:right;">${upgradeBtn}</span>
    </div>
    <div style="clear:both;"></div>
  `;

  // --- –ò—Ç–æ–≥–æ–≤—ã–π HTML ---
  let info = `<b style="font-size:17px;display:block;text-align:center;margin-bottom:5px;">${conf.name}</b>${stats}${buttons}`;
  const el = document.getElementById('tower-info');
  if (el) {
    el.innerHTML = info;
    el.style.display = "";
  } else {
    console.warn('showTowerInfo: —ç–ª–µ–º–µ–Ω—Ç #tower-info –Ω–µ –Ω–∞–π–¥–µ–Ω');
  }

  // –õ–æ–≥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø –±–∞—à–Ω–∏ –∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
  console.log(`showTowerInfo: –ø–æ–∫–∞–∑–∞–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–∞—à–Ω–µ "${conf.name}" (type=${type})`);
}

// --- –ö–Ω–æ–ø–∫–∏ ---
function mkBtn(label, cb, color, enabled = true) {
  const style = `background:${color};color:${isLight(color) ? '#222' : '#fff'};font-weight:bold;min-width:90px;cursor:${enabled ? 'pointer' : 'not-allowed'};margin:0 5px 0 5px;padding:7px 15px;border-radius:7px;border:2px solid #222;font-size:16px;${enabled ? '' : 'filter: grayscale(0.7) brightness(0.65);'}`;
  return `<button${enabled ? '' : ' disabled="disabled"'} style="${style}" onclick="${enabled ? cb : 'void(0)'}">${label}</button>`;
}

function sellTower(x, y) {
  let cell = grid[y][x];
  if (!cell.tower) return false;
  let type = cell.tower.type;
  let refund = Math.round(0.5 * towerData[type].cost);
  money += refund;
  // –£–¥–∞–ª—è–µ–º –±–∞—à–Ω—é –∏–∑ –º–∞—Å—Å–∏–≤–∞ –∏ –∏–∑ —Å–µ—Ç–∫–∏:
  let ind = towers.indexOf(cell.tower);
  if (ind > -1) towers.splice(ind, 1);
  grid[y][x].tower = null;
  grid[y][x].blocked = false;
  updateUI();
  hideTowerInfo();
  generateEnemyPath();
  recalcPathsForAllEnemies();
  return true;
}

function upgradeTower(x, y) {
  let cell = grid[y][x];
  if (!cell.tower) return false;
  let curType = cell.tower.type;
  let nextType = getNextTowerType(curType);
  if (nextType === null) return false;
  let upgradeCost = towerData[nextType].cost;
  if (money < upgradeCost) return false;
  money -= upgradeCost;
  cell.tower.type = nextType;
  updateUI();
  showTowerInfo(nextType, x, y); // <-- –æ—Å—Ç–∞—ë—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º, –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –Ω–∞ –Ω–æ–≤—É—é –±–∞—à–Ω—é
  return true;
}

function downgradeTower(x, y) {
  let cell = grid[y][x];
  if (!cell.tower) return false;
  let curType = cell.tower.type;
  let prevType = getPrevTowerType(curType);
  if (prevType === null) return false;
  let downgradeRefund = towerData[prevType].cost;
  money += downgradeRefund;
  cell.tower.type = prevType;
  updateUI();
  showTowerInfo(prevType, x, y); // <-- –æ—Å—Ç–∞—ë—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º, –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –Ω–∞ –Ω–æ–≤—É—é –±–∞—à–Ω—é
  return true;
}

function hideTowerInfo() {
  const el = document.getElementById('tower-info');
  if (el) {
    el.style.display = "none";
  }
}

function createUIButtons() {
  let panel = document.getElementById('ui-panel');
  if (!panel) {
    console.warn('createUIButtons: —ç–ª–µ–º–µ–Ω—Ç #ui-panel –Ω–µ –Ω–∞–π–¥–µ–Ω');
    return;
  }

  let html = '';
  html += `<span class="money">${money}</span> | `;
  html += `<span class="health">${health} –∂–∏–∑–Ω–µ–π</span> | `;
  html += `<span class="wave">${wave} / ${waveData.length} –≤–æ–ª–Ω–∞</span>  `;
  html += '<hr style="margin:6px 2px">';

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è —Ü–≤–µ—Ç–∞
  function darkenColor(hex, percent) {
    let num = parseInt(hex.replace("#", ""), 16);
    let r = (num >> 16) & 0xFF,
      g = (num >> 8) & 0xFF,
      b = num & 0xFF;
    r = Math.round(r * (1 - percent));
    g = Math.round(g * (1 - percent));
    b = Math.round(b * (1 - percent));
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ (–¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –≥–ª–æ–±–∞–ª—å–Ω–æ–π, –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏)
  function isLight(color) {
    if (!color) return false;
    color = color.replace('#', '');
    let r = parseInt(color.substring(0, 2), 16);
    let g = parseInt(color.substring(2, 4), 16);
    let b = parseInt(color.substring(4, 6), 16);
    return (r * 0.299 + g * 0.587 + b * 0.114) > 180;
  }

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ –±–∞—à–µ–Ω
  for (let i = 0; i < towerData.length; ++i) {
    let baseColor = towerData[i].color;
    let affordable = money >= towerData[i].cost;
    let background = affordable ? baseColor : darkenColor(baseColor, 0.6);
    let textColor = isLight(background) ? "#282828" : "#fff";
    if (!affordable) textColor = "#888";
    let selClass = (selectedTowerType == i ? "selected" : "");
    let btnStyle = `background:${background};color:${textColor};border:1.5px solid #222;`;

    html += `<button 
      style="${btnStyle}" 
      onclick="selectTowerType(${i})" 
      id="btn-tower-${i}" 
      ${affordable ? '' : 'disabled'} 
      class="${selClass}">
        ${towerData[i].name} ${towerData[i].cost}
      </button> 
      <button onclick="showTowerInfo(${i})" 
        style="margin:2px 6px 2px 1px;padding:1.5px 7px;border-radius:4px;background:#202028;color:#fabd32;font-size:13px;border:1px solid #575750;vertical-align:middle;cursor:pointer;"
        title="–ü–æ–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã">
        i
      </button>
    `;
  }

  // –ö–Ω–æ–ø–∫–∏ –∞–ø–≥—Ä–µ–π–¥–∞ –∏ –ø—Ä–æ–¥–∞–∂–∏ –±–∞—à–Ω–∏ (–ø–æ—è–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –±–∞—à–Ω–∏)
  if (selectedTowerType !== null) {
    html += `<div class="upgrade-sell-buttons">`;
    html += `<button onclick="upgradeTower()">–ê–ø–≥—Ä–µ–π–¥</button>`;
    html += `<button onclick="sellTower()">–ü—Ä–æ–¥–∞—Ç—å</button>`;
    html += `</div>`;
  }

  // –ö–Ω–æ–ø–∫–∞ —Å–Ω—è—Ç–∏—è –≤—ã–±–æ—Ä–∞
  html += `<button onclick="clearTowerSelection()">&#x2716; –°–Ω—è—Ç—å –≤—ã–±–æ—Ä</button>`;

  // -- –°—Ç–∏–ª—å–Ω—ã–µ —Ö–æ—Ç–∫–µ–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–π F-–∫–Ω–æ–ø–∫–∏ --
  html += `<br>
    <small>
      <span style="color:#727c88;">1,2,3</span> ‚Äî –±—ã—Å—Ç—Ä–æ –≤—ã–±—Ä–∞—Ç—å –±–∞—à–Ω—é 
      &nbsp;‚Ä¢&nbsp; 
      <span style="color:#de4541;">–ü–ö–ú</span> ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å –≤—ã–±–æ—Ä
      <br>
      <span style="color:#7ad436;font-weight:bold;background:#202f16;padding:0 4px 0 6px;border-radius:3px;">F8</span> 
      ‚Äî dev —Ä–µ–∂–∏–º &nbsp; 
      <span style="color:#308fc7;font-weight:bold;background:#12263c;padding:0 4px 0 6px;border-radius:3px;">F9</span> 
      ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç –∏–≥—Ä—ã &nbsp; 
      <span style="color:#c44be0;font-weight:bold;background:#231035;padding:0 4px 0 6px;border-radius:3px;">F10</span> 
      ‚Äî —Å–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
    </small>`;

  panel.innerHTML = html;
}

function updateUI() {
  createUIButtons();
}

function selectTowerType(i) {
  if (money < towerData[i].cost) return false;
  selectedTowerType = i;
  isPlacingTower = true;
  buildZoneHints = [];
  placingTowerCell = null;
  updateUI();
}

function clearTowerSelection() {
  selectedTowerType = null;
  isPlacingTower = false;
  buildZoneHints = [];
  placingTowerCell = null;
  updateUI();
}


// –°–∫—Ä—ã—Ç—å –æ–∫–Ω–æ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –±–∞—à–Ω–µ
function hideTowerInfo() {
  const el = document.getElementById('tower-info');
  if (el) {
    el.style.display = "none";
  }
  // –°–±—Ä–æ—Å –≤—ã–¥–µ–ª–µ–Ω–∏—è –±–∞—à–Ω–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  // selectedTowerType = null;
  // isPlacingTower = false;
  // –ú–æ–∂–Ω–æ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–±—Ä–∞—Å—ã–≤–∞—Ç—å –≤—ã–±–æ—Ä
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –ø–æ —Å–µ—Ç–∫–µ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∞—à–Ω–∏
function handleGridClick(x, y) {
  if (gameOver || victory) return;

  const cell = grid[y][x];

  // –ï—Å–ª–∏ —Å–µ–π—á–∞—Å –≤ —Ä–µ–∂–∏–º–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∞—à–Ω–∏
  if (isPlacingTower && selectedTowerType !== null) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–∂–Ω–æ –ª–∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–∞—à–Ω—é –Ω–∞ —ç—Ç—É –∫–ª–µ—Ç–∫—É
    if (!cell.blocked && !cell.tower && canPlaceTowerHere(x, y)) {
      let cost = towerData[selectedTowerType].cost;
      if (money >= cost) {
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∞—à–Ω—é
        const tower = createTower(x, y, selectedTowerType);
        towers.push(tower);
        cell.tower = tower;
        cell.blocked = true;  // –∫–ª–µ—Ç–∫–∏ —Å –±–∞—à–Ω—è–º–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–ª—è –≤—Ä–∞–≥–æ–≤

        money -= cost;
        isPlacingTower = false;
        selectedTowerType = null;
        placingTowerCell = null;

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç–∏ –≤—Ä–∞–≥–æ–≤, —Ç.–∫. –∫–∞—Ä—Ç–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å
        generateEnemyPath();
        recalcPathsForAllEnemies();

        updateUI();
        hideTowerInfo();
      } else {
        alert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–µ–Ω–µ–≥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∞—à–Ω–∏.");
      }
    } else {
      alert("–ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –±–∞—à–Ω—é —Å—é–¥–∞.");
    }
    return;
  }

  // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –±–∞—à–Ω–µ ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
  if (cell.tower) {
    showTowerInfo(cell.tower.type, x, y);
  } else {
    hideTowerInfo();
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –±–∞—à–Ω—é –Ω–∞ –∫–ª–µ—Ç–∫—É (x,y)
function canPlaceTowerHere(x, y) {
  // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —Å—Ç–∞—Ä—Ç –∏ —Ñ–∏–Ω–∏—à
  if (startCell.x === x && startCell.y === y) return false;
  if (finishCell.x === x && finishCell.y === y) return false;
  // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ —É–∂–µ –∑–∞–Ω—è—Ç—ã–µ –∫–ª–µ—Ç–∫–∏
  if (grid[y][x].tower) return false;
  // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
  return true;
}

// –°–æ–∑–¥–∞—Ç—å –æ–±—ä–µ–∫—Ç –±–∞—à–Ω–∏
function createTower(x, y, type) {
  let conf = towerData[type];
  return {
    x,
    y,
    type,
    conf,
    cooldown: 0,
    cx: x * CELL_SIZE + CELL_SIZE / 2,
    cy: y * CELL_SIZE + CELL_SIZE / 2,
    range: conf.range,
  };
}

// –û–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–µ–Ω–µ–≥, –∂–∏–∑–Ω–µ–π, –≤–æ–ª–Ω—ã –∏ –∫–Ω–æ–ø–æ–∫
function updateUI() {
  createUIButtons();
  updateStatusBar();
}

// –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å–±–∞—Ä (–∂–∏–∑–Ω–∏, –¥–µ–Ω—å–≥–∏, –≤–æ–ª–Ω–∞)
function updateStatusBar() {
  let moneyEl = document.getElementById('money-display');
  if (moneyEl) moneyEl.textContent = `–î–µ–Ω—å–≥–∏: ${money}`;
  let healthEl = document.getElementById('health-display');
  if (healthEl) healthEl.textContent = `–ñ–∏–∑–Ω–∏: ${health}`;
  let waveEl = document.getElementById('wave-display');
  if (waveEl) waveEl.textContent = `–í–æ–ª–Ω–∞: ${wave} / ${waveData.length}`;
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI ‚Äî —Å–æ–∑–¥–∞—ë–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
function initUI() {
  if (!document.getElementById('ui-panel')) {
    const uiPanel = document.createElement('div');
    uiPanel.id = 'ui-panel';
    uiPanel.style.padding = '8px';
    document.body.appendChild(uiPanel);
  }
  if (!document.getElementById('tower-info')) {
    const towerInfo = document.createElement('div');
    towerInfo.id = 'tower-info';
    towerInfo.style.position = 'absolute';
    towerInfo.style.top = '10px';
    towerInfo.style.right = '10px';
    towerInfo.style.backgroundColor = 'rgba(30,30,30,0.9)';
    towerInfo.style.color = '#fff';
    towerInfo.style.padding = '12px';
    towerInfo.style.borderRadius = '8px';
    towerInfo.style.display = 'none';
    towerInfo.style.maxWidth = '250px';
    towerInfo.style.zIndex = '100';
    document.body.appendChild(towerInfo);
  }
  if (!document.getElementById('status-bar')) {
    const statusBar = document.createElement('div');
    statusBar.id = 'status-bar';
    statusBar.style.position = 'fixed';
    statusBar.style.bottom = '10px';
    statusBar.style.left = '10px';
    statusBar.style.backgroundColor = 'rgba(0,0,0,0.7)';
    statusBar.style.color = '#fff';
    statusBar.style.padding = '6px 12px';
    statusBar.style.borderRadius = '6px';
    statusBar.style.fontSize = '16px';
    statusBar.style.fontFamily = 'monospace';
    statusBar.innerHTML = `
      <span id="money-display"></span> | 
      <span id="health-display"></span> | 
      <span id="wave-display"></span>
    `;
    document.body.appendChild(statusBar);
  }
  updateUI();
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ‚Äî –≤—ã–∑–æ–≤ initUI –≤ –Ω–∞—á–∞–ª–µ –∏–≥—Ä—ã
initUI();



// ===== 13. –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ =====  
function getCellFromMouse(e) {  
  let rect = canvas.getBoundingClientRect();  
  let mx = e.clientX - rect.left, my = e.clientY - rect.top;  
  let x = Math.floor(mx / CELL_SIZE), y = Math.floor(my / CELL_SIZE);  
  if (x<0||y<0||x>=GRID_SIZE||y>=GRID_SIZE) return null;  
  return [x,y];  
}  
function distance(x1,y1,x2,y2) { return Math.hypot(x1-x2,y1-y2); }  

// ===== 14. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –≤–≤–æ–¥ =====  
function handleKeyDown(e) {  
  // –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –±–∞—à–Ω–∏ –ø–æ 1 2 3
  if ("123".includes(e.key)) {  
    let idx = parseInt(e.key) - 1;  
    if (idx < towerData.length && money >= towerData[idx].cost) {   
      selectedTowerType = idx; 
      isPlacingTower = true;   
      buildZoneHints = [];  
      updateUI();   
    }  
  }  
  // –í–ö–õ/–í–´–ö–õ DEV MODE –ø–æ F8
  if (e.key === "F8") toggleDevMode();  
  // –†–µ—Å—Ç–∞—Ä—Ç –ø–æ F9
  if (e.key === "F9") restartGame();  
  // –û—á–∏—Å—Ç–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ F10
  if (e.key === "F10") clearSavedGameState();  
}

// –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏–≥—Ä—ã (–ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ)
function restartGame() {   
  // –£–¥–∞–ª—è–µ–º —Ç–∞–±–ª–∏—á–∫–∏ –ø–æ—Ä–∞–∂–µ–Ω–∏—è –∏ –ø–æ–±–µ–¥—ã, –µ—Å–ª–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç
  let go = document.querySelector('.gameover');
  if (go) go.remove();
  let vic = document.querySelector('.victory');
  if (vic) vic.remove();

  waveTimeoutActive = false;
  wavePauseLeft = 0;
  document.getElementById('wave-timer').style.display = "none";
  buildZoneHints = [];
  init();   
}

// –í–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∏ –ø–∞–Ω–µ–ª–∏ debug
function toggleDevMode() {
  devMode = !devMode;
  document.getElementById('dev-panel').style.display = devMode ? "" : "none";
  updateUI();
}

// –î–ª—è –æ—Ç–ª–∞–¥–æ—á–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è/—Å–Ω–∏–º–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
function logGameState() {
  debugLogEvent('full_state', JSON.stringify({
    grid, enemies, towers, bullets, health, money, wave
  }));
}
// ===== 15. –î–µ–±–∞–≥ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ =====  
function debugDrawPath(p) {  
  if (!devMode||!p.length) return;  
  ctx.save();  
  ctx.globalAlpha=0.37;  
  ctx.strokeStyle = "#ffee22";  
  ctx.lineWidth=3;  
  ctx.beginPath();  
  for (let i=0; i<p.length; ++i) {  
    let [x,y]=p[i];  
        ctx[i==0?"moveTo":"lineTo"](x*CELL_SIZE+CELL_SIZE/2,y*CELL_SIZE+CELL_SIZE/2);
  }
  ctx.stroke();
  ctx.globalAlpha=1;
  ctx.restore();

  // dev info
  let html = '';
  if (devLog.length>30) devLog.splice(0, devLog.length-30);
  html += "<b>[DEV]</b> wave:"+wave+" | mon:$"+money+" | hp:"+health+"<br>";
  html += "towers:"+towers.length + " | enemies:"+enemies.length+"<br>";
  html += path.length?"path len="+path.length+"":"no path!";
  html += "<br><pre style='max-height:8em;overflow:auto;'>"+devLog.map(e=>JSON.stringify(e)).join("\n")+"</pre>";
  document.getElementById('dev-panel').innerHTML = html;
}
function debugLogEvent(ev, data) { if (devMode) devLog.push({ev, data, t:(+Date.now()).toString(36).substr(-5)}); }

// ===== 16. –ü–æ–±–µ–¥–∞ –∏ –ø–æ—Ä–∞–∂–µ–Ω–∏–µ =====
function checkGameOver() {
  if (!gameOver && health <= 0) { showGameOverScreen(); gameOver=true;defeatCause="lose"; }
}
function showGameOverScreen() {
  let d = document.createElement("div");
  d.className = "gameover";
  d.innerHTML = "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ<br>–í–æ–ª–Ω–∞: "+wave+"<br><button onclick='restartGame()'>–†–µ—Å—Ç–∞—Ä—Ç</button>";
  d.style.zIndex=5;
  if (!document.querySelector('.gameover')) document.body.appendChild(d);
}
function checkVictoryCondition() {
  if (!victory && wave > waveData.length && enemies.length === 0 && !waveTimeoutActive) {
    showVictoryScreen(); victory=true;defeatCause="win";
  }
}
function showVictoryScreen() {
  let d = document.createElement("div");
  d.className = "victory";
  d.innerHTML = "–í—ã –ø–æ–±–µ–¥–∏–ª–∏!<br>–í–æ–ª–Ω—ã: "+waveData.length+"<br><button onclick='restartGame()'>–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>";
  d.style.zIndex=6;
  if (!document.querySelector('.victory')) document.body.appendChild(d);
}

// ===== 17. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) =====
function saveGameStateToLocalStorage() {
  let state = {grid,towers,enemies,bullets,health, money, wave, devLog};
  localStorage.setItem("td_save",JSON.stringify(state));
}
function loadGameStateFromLocalStorage() {
  let data = localStorage.getItem("td_save");
  if (!data) return;
  let s = JSON.parse(data);
  grid=s.grid; towers=s.towers;enemies=s.enemies;bullets=s.bullets;
  health=s.health;money=s.money;wave=s.wave;devLog=s.devLog;
  updateUI();
}
function clearSavedGameState() { localStorage.removeItem('td_save'); restartGame(); }

// ===== 18. –≠–∫—Å–ø–æ—Ä—Ç —Ñ—É–Ω–∫—Ü–∏–π –≤ –≥–ª–æ–±–∞–ª –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ =====
window.selectTowerType       = selectTowerType;
window.clearTowerSelection   = clearTowerSelection;
window.upgradeTower          = upgradeTower;
window.downgradeTower        = downgradeTower;
window.showTowerInfo         = showTowerInfo;
window.hideTowerInfo         = hideTowerInfo;
window.sellTower             = sellTower;
window.clearSavedGameState   = clearSavedGameState;

window.onload = () => init();
window.addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
